<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN" "JATS-archivearticle1.dtd"> 
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" open-status="O" article-type="research-article"><?properties open_access?><?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?><?DTDIdentifier.IdentifierType public?><?SourceDTD.DTDName JATS-journalpublishing1.dtd?><?SourceDTD.Version 1.1?><?ConverterInfo.XSLTName jp2nlmx2.xsl?><?ConverterInfo.Version 1?><front><journal-meta><journal-id journal-id-type="nlm-ta">J Integr Bioinform</journal-id><journal-id journal-id-type="iso-abbrev">J Integr Bioinform</journal-id><journal-id journal-id-type="publisher-id">jib</journal-id><journal-id journal-id-type="doi">jib</journal-id><journal-id journal-id-type="pmc">jib</journal-id><journal-title-group><journal-title>Journal of Integrative Bioinformatics</journal-title></journal-title-group><issn pub-type="epub">1613-4516</issn><publisher><publisher-name>De Gruyter</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">6340127</article-id><article-id pub-id-type="publisher-id">jib-2017-0057</article-id><article-id pub-id-type="doi">10.1515/jib-2017-0057</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Articles</subject></subj-group></article-categories><title-group><article-title><SecTag type="TITLE"><text><SENT sid="88339" pm="."><plain>Modified HuffBit Compress Algorithm – An Application of R </plain></SENT>
</text></SecTag></article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes"><name><surname>Habib</surname><given-names>Nahida</given-names></name><email>nahidahabib164@yahoo.com</email><xref ref-type="aff" rid="j_jib-2017-0057_aff_001"/></contrib><contrib contrib-type="author"><name><surname>Ahmed</surname><given-names>Kawsar</given-names></name><xref ref-type="aff" rid="j_jib-2017-0057_aff_002"/></contrib><contrib contrib-type="author"><name><surname>Jabin</surname><given-names>Iffat</given-names></name><xref ref-type="aff" rid="j_jib-2017-0057_aff_003"/></contrib><contrib contrib-type="author"><name><surname>Rahman</surname><given-names>Mohammad Motiur</given-names></name><xref ref-type="aff" rid="j_jib-2017-0057_aff_003"/></contrib><aff id="j_jib-2017-0057_aff_001"><institution content-type="dept">Department of Computer Science and Engineering (CSE)</institution>, <institution>Mawlana Bhashani Science and Technology University (MBSTU)</institution>, <addr-line>Santosh</addr-line>, <city>Tangail 1902</city>, <country country="BD">Bangladesh</country></aff><aff id="j_jib-2017-0057_aff_002"><institution content-type="dept">Department of Information and Communication Technology (ICT)</institution>, <institution>Mawlana Bhashani Science and Technology University (MBSTU)</institution>, <city>Tangail</city>, <country country="BD">Bangladesh</country></aff><aff id="j_jib-2017-0057_aff_003"><institution content-type="dept">Department of Computer Science and Engineering (CSE)</institution>, <institution>Mawlana Bhashani Science and Technology University (MBSTU)</institution>, <city>Tangail</city>, <country country="BD">Bangladesh</country></aff></contrib-group><pub-date pub-type="epub"><day>22</day><month>2</month><year>2018</year></pub-date><pub-date pub-type="collection"><month>9</month><year>2018</year></pub-date><volume>15</volume><issue>3</issue><elocation-id seq="5">20170057</elocation-id><history><date date-type="received"><day>23</day><month>7</month><year>2017</year></date><date date-type="rev-recd"><day>02</day><month>1</month><year>2018</year></date><date date-type="accepted"><day>25</day><month>1</month><year>2018</year></date></history><permissions><copyright-statement>©2018 Nahida Habib et al., published by De Gruyter, Berlin/Boston</copyright-statement><copyright-year>2018</copyright-year><copyright-holder>Nahida Habib et al., published by De Gruyter, Berlin/Boston</copyright-holder><license license-type="open-access" specific-use="rights-object-archive-dnb" xlink:href="http://creativecommons.org/licenses/by-nc-nd/3.0"><license-p>This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 3.0 License.</license-p></license></permissions><abstract><title><text><SENT sid="88340" pm="."><plain>Abstract </plain></SENT>
</text></title><p><SecTag type="ABS"><text><SENT sid="88341" pm="."><plain>The databases of genomic sequences are growing at an explicative rate because of the increasing growth of living organisms. </plain></SENT>
<SENT sid="88342" pm="."><plain>Compressing deoxyribonucleic acid (DNA) sequences is a momentous task as the databases are getting closest to its threshold. </plain></SENT>
<SENT sid="88343" pm="."><plain>Various compression algorithms are developed for DNA sequence compression. </plain></SENT>
<SENT sid="88344" pm="."><plain>An efficient DNA compression algorithm that works on both repetitive and non-repetitive sequences known as “HuffBit Compress” is based on the concept of Extended Binary Tree. </plain></SENT>
<SENT sid="88345" pm="."><plain>In this paper, here is proposed and developed a modified version of “HuffBit Compress” algorithm to compress and decompress DNA sequences using the R language which will always give the Best Case of the compression ratio but it uses extra 6 bits to compress than best case of “HuffBit Compress” algorithm and can be named as the “Modified HuffBit Compress Algorithm”. </plain></SENT>
<SENT sid="88346" pm="."><plain>The algorithm makes an extended binary tree based on the Huffman Codes and the maximum occurring bases (A, C, G, T). </plain></SENT>
<SENT sid="88347" pm="."><plain>Experimenting with 6 sequences the proposed algorithm gives approximately 16.18 % improvement in compression ration over the “HuffBit Compress” algorithm and 11.12 % improvement in compression ration over the “2-Bits Encoding Method”. </plain></SENT>
</text></SecTag></p></abstract><SecTag type="KEYWORD"><kwd-group><title>Keywords</title><kwd>Compression and Decompression</kwd><kwd>Compression Ratio</kwd><kwd>Extended Binary Tree</kwd><kwd>HuffBit Compress</kwd><kwd>2-Bits Encoding Method</kwd></kwd-group></SecTag><counts><fig-count count="7"/><table-count count="2"/><ref-count count="24"/><page-count count="13"/></counts></article-meta></front><body><SecTag type="INTRO"><sec id="j_jib-2017-0057_s_001"><label>1</label><title><text><SENT sid="88348" pm="."><plain>Introduction </plain></SENT>
</text></title><p><text><SENT sid="88349" pm="."><plain>R is one of the most popular languages used by statisticians, data analysts, researchers and marketers to retrieve, clean, analyze, visualize and present data [1]. </plain></SENT>
<SENT sid="88350" pm="."><plain>It is an interactive environment providing a wide variety of statistical and graphical techniques. </plain></SENT>
<SENT sid="88351" pm="."><plain>The R tool has become more popular among statisticians, mathematicians, computer scientists and researchers because of its excessive number of libraries and packages and ease of use. </plain></SENT>
<SENT sid="88352" pm="."><plain>The R tool can also be applied in genetic applications. </plain></SENT>
<SENT sid="88353" pm="."><plain>It is an implementation of the S programming language and has an estimated two million users [2], [3]. </plain></SENT>
</text></p><p><text><SENT sid="88354" pm="."><plain>The genome contains all of the information needed to build and maintain an organism. </plain></SENT>
<SENT sid="88355" pm="."><plain>In humans, a copy of the entire genome – more than 3 billion deoxyribonucleic acid (DNA) base pairs – is contained in all cells that have a nucleus [4] and more than 99 % pairs are the same in all humans [5]. </plain></SENT>
<SENT sid="88356" pm="."><plain>A DNA chain is made of four bases: adenine (A), guanine (G), thymine (T) and cytosine (C). </plain></SENT>
<SENT sid="88357" pm="."><plain>These four chemical bases always bond with the same co-partner to comprise base pairs. </plain></SENT>
<SENT sid="88358" pm="."><plain>For a complete genome a DNA sequence can be represented as a very long text containing only the bases (A, C, G, T) [6]. </plain></SENT>
</text></p><p><text><SENT sid="88359" pm="."><plain>A text-based format known as FASTA format can be used to represent or store a DNA sequence. </plain></SENT>
<SENT sid="88360" pm="."><plain>Some other formats include Plain sequence format, FASTQ format, EMBL format, GCG format, GCG-RSF format, GenBank format and IG format [7]. </plain></SENT>
</text></p><p><text><SENT sid="88361" pm="."><plain>Thousands of nucleotides are sequenced every day. </plain></SENT>
<SENT sid="88362" pm="."><plain>From 1982 to the present, the number of bases in GenBank has doubled approximately every 18 months [8]. </plain></SENT>
<SENT sid="88363" pm="."><plain>Approximately 228719437638 bases are there in the GenBank database in February 2017 [8]. </plain></SENT>
<SENT sid="88364" pm="."><plain>As a result, it becomes very hard to maintain, process, and store the large dataset in the database. </plain></SENT>
<SENT sid="88365" pm="."><plain>Again, finding the characteristics and comparing Genomes is a major task [9], [10]. </plain></SENT>
<SENT sid="88366" pm="."><plain>So it is clear that, DNA sequences should be compressible which is an analytical method created by bioinformatics. </plain></SENT>
</text></p><p><text><SENT sid="88367" pm="."><plain>Biological sequence compression is an effective apparatus to extract information from biological sequences. </plain></SENT>
<SENT sid="88368" pm="."><plain>With respect to computer science data compression stands for curtailment of the size of memory used to store a data. </plain></SENT>
<SENT sid="88369" pm="."><plain>From a mathematical point of view, compression implies better understanding and comprehension [11]. </plain></SENT>
<SENT sid="88370" pm="."><plain>The compression of DNA sequences is not an easy task [6], [12]. </plain></SENT>
<SENT sid="88371" pm="."><plain>General purpose compression algorithms fail to perform well with biological sequences. </plain></SENT>
<SENT sid="88372" pm="."><plain>Most of the Existing software tools worked well for English text compression [13] but not for DNA Genomes. </plain></SENT>
<SENT sid="88373" pm="."><plain>Lossless and lossy are two compression techniques. </plain></SENT>
<SENT sid="88374" pm="."><plain>In lossless compression all of the information is completely restored after decompression. </plain></SENT>
<SENT sid="88375" pm="."><plain>While in the lossy technique, we loss some of the data and do not recover the complete original data after decompression. </plain></SENT>
</text></p><p><text><SENT sid="88376" pm="."><plain>The proposed research is a lossless compression algorithm which builds an Extended Binary Tree for DNA sequences by assigning binary codes (0 and 1) to each base to compress both repetitive and non-repetitive DNA sequences. </plain></SENT>
<SENT sid="88377" pm="."><plain>The algorithm is implemented using R. This paper is organized in 6 sections. </plain></SENT>
<SENT sid="88379" pm="."><plain>Section 2 presents the background and previous work related to the research, Section 3 describes the proposed methodology and working principle, Section 4 presents the results, Section 5 discusses and analyzes the results, and last but not least Section 6 includes conclusion and future work. </plain></SENT>
</text></p></sec></SecTag><SecTag type="INTRO"><sec id="j_jib-2017-0057_s_002"><label>2</label><title><text><SENT sid="88380" pm="."><plain>Related Work </plain></SENT>
</text></title><p><text><SENT sid="88381" pm="."><plain>Due to not using special structures of biological sequences, the standard compression techniques cannot compress the biological sequences well. </plain></SENT>
<SENT sid="88382" pm="."><plain>Recently, several algorithms have been proposed for the compression of DNA sequences based on DNA sequence special structures. </plain></SENT>
<SENT sid="88383" pm="."><plain>Two lossless compression algorithms named BioCompress [14] and BioCompress-2 [6] were proposed by Grumbach and Tahi. </plain></SENT>
<SENT sid="88384" pm="."><plain>These algorithms were based on Ziv and Lempel data compression method [15], [16]. </plain></SENT>
<SENT sid="88385" pm="."><plain>They search the previously processed part of the sequence for repeats. </plain></SENT>
<SENT sid="88386" pm="."><plain>BioCompress-2 is the extended version of BioCompress which uses the arithmetic coding of order 2 if no significant repetition is found. </plain></SENT>
<SENT sid="88387" pm="."><plain>The results showed that both algorithms compressed the standard benchmark data with an average compression ratio of 1.850 bpb for Biocompress and 1.783 bpb for Biocompress 2 [17]. </plain></SENT>
<SENT sid="88388" pm="."><plain>Decompression may demean the algorithm performance, as it requires reference to the starting of the sequence which requires more memory reference [18]. </plain></SENT>
</text></p><p><text><SENT sid="88389" pm="."><plain>The Cfact [19] used a two-pass algorithm to search for the longest exact and reverse complement repeats. </plain></SENT>
<SENT sid="88390" pm="."><plain>It builds the suffix tree of the sequence and then encodes using LZ. </plain></SENT>
<SENT sid="88391" pm="."><plain>Non-repeat regions are also encoded by 2 bpb. </plain></SENT>
<SENT sid="88392" pm="."><plain>There are no compression results about this algorithm; therefore it is difficult to compare [17]. </plain></SENT>
<SENT sid="88393" pm="."><plain>It works similar to Biocompress, but takes more compression time, since it uses two passes, and constructs a suffix tree. </plain></SENT>
</text></p><p><text><SENT sid="88394" pm="."><plain>GenCompress is a one pass algorithm which is based on LZ77. </plain></SENT>
<SENT sid="88395" pm="."><plain>This algorithm carefully finds the optimal prefix and uses order-2 arithmetic encoding whenever needed [13]. </plain></SENT>
<SENT sid="88396" pm="."><plain>It searches for both approximate matches and the approximate complimented palindrome. </plain></SENT>
<SENT sid="88397" pm="."><plain>There are two versions of GenCompress: GenCompress-1 uses the Hamming distance with replacement or substitution operations only. </plain></SENT>
<SENT sid="88398" pm="."><plain>GenCompress-2 uses edit distance based on the insert and delete operation. </plain></SENT>
<SENT sid="88399" pm="."><plain>GenCompress achieves 1.742 bpb which is a higher compression ratio compared to BioCompress-2 [17]. </plain></SENT>
</text></p><p><text><SENT sid="88400" pm="."><plain>DNACompress [20] is the modified algorithm of GenCompress which is a two-pass algorithm. </plain></SENT>
<SENT sid="88401" pm="."><plain>It also uses Lempel-Ziv compression scheme which finds all the approximate repeats including complemented palindromes using a software tool called Pattern Hunter [21]. </plain></SENT>
<SENT sid="88402" pm="."><plain>It encrypts approximate repeat and non-repeat regions. </plain></SENT>
<SENT sid="88403" pm="."><plain>DNACompress was able to deal with large sequences (e.g. E. coli with about 4.6 Megabases) in about a minute, where GenCompress required nearly about half an hour [17]. </plain></SENT>
<SENT sid="88404" pm="."><plain>This algorithm achieves a compression rate of 1.72 bpb. </plain></SENT>
</text></p><p><text><SENT sid="88405" pm="."><plain>Huffman coding or 2 Bits Encoding Method is based on building a binary tree according to the bases frequencies. </plain></SENT>
<SENT sid="88406" pm="."><plain>Each base is represented by 2 bits and assigned as A = 00, C = 01, G = 10, T = 11. </plain></SENT>
<SENT sid="88407" pm="."><plain>As a result, it requires 2400 bits of space when the sequence length is 1200. </plain></SENT>
<SENT sid="88408" pm="."><plain>That is, the storage of encoded sequence is almost the double of its original sequence length [6]. </plain></SENT>
</text></p><p><text><SENT sid="88409" pm="."><plain>HuffBit Compress Algorithm [22] uses the concept of extended binary trees for compression. </plain></SENT>
<SENT sid="88410" pm="."><plain>It assigns a zero for left child and one for right child. </plain></SENT>
<SENT sid="88411" pm="."><plain>It is a two way process; in the initial phase it constructs an extended binary tree then replaces the sequences using the codes generated from the tree. </plain></SENT>
<SENT sid="88412" pm="."><plain>The algorithm replaces a, c, g, t by a constant binary value where a is replaced by 0, c is replaced by 10, g is replaced by 110 and t is replaced by 111. </plain></SENT>
<SENT sid="88413" pm="."><plain>It achieves a compression ratio of 1.006 bpb for the best case, 1.611 bpb for the average case, and 2.109 bpb for the worst case. </plain></SENT>
<SENT sid="88414" pm="."><plain>In most of the cases it fails to achieve the best case compression ratio. </plain></SENT>
</text></p><p><text><SENT sid="88415" pm="."><plain>From the above discussion, it is clear that day by day research work on compressing DNA sequences is increasing and each algorithm comes with a better compression ratio. </plain></SENT>
<SENT sid="88416" pm="."><plain>Each descendant algorithm comes reducing the disadvantages of previous algorithms. </plain></SENT>
<SENT sid="88417" pm="."><plain>For example, BioCompress 2 gives better compression ratio than BioCompress1 but the storage complexity of them are high. </plain></SENT>
<SENT sid="88418" pm="."><plain>Again, GenCompress gives better compression ratio than BioCompress2 but takes more time for large sequence compared to DNACompress. </plain></SENT>
<SENT sid="88419" pm="."><plain>Cfact is more complex in case of time. </plain></SENT>
<SENT sid="88420" pm="."><plain>Huffman coding has a problem of storage complexity. </plain></SENT>
<SENT sid="88421" pm="."><plain>For worst case Huffbit Compress compression ratio is not satisfactory. </plain></SENT>
<SENT sid="88422" pm="."><plain>In this article, it has been tried to achieve a better compression factor than existing compression programs using the repeat and non-repeat sequence. </plain></SENT>
<SENT sid="88423" pm="."><plain>Moreover, the proposed algorithm is simple, easy to implement, takes less memory space and most of the cases gives better compression ratio than HuffBit Compress Algorithm and 2 Bits Encoding Method. </plain></SENT>
</text></p></sec></SecTag><SecTag type="METHODS"><sec id="j_jib-2017-0057_s_003"><label>3</label><title><text><SENT sid="88424" pm="."><plain>Proposed Methodology </plain></SENT>
</text></title><p><text><SENT sid="88425" pm="."><plain>The proposed algorithm works on two phases. </plain></SENT>
<SENT sid="88426" pm="."><plain>In the first phase it uses Huffman code to generate an extended binary tree based on the frequencies of the bases. </plain></SENT>
<SENT sid="88427" pm="."><plain>In the second phase, each base is replaced by its corresponding binary bits generated from the tree. </plain></SENT>
<SENT sid="88428" pm="."><plain>Compression and decompression of the DNA sequences are performed using R. Several steps are performed in this manner as described in the subsections through 3.1 to 3.6. </plain></SENT>
<SENT sid="88430" pm="."><plain>A flowchart showing the proposed methodology including compression and decompression method is noticed in Figure 1. </plain></SENT>
</text></p><SecTag type="FIG"><fig id="j_jib-2017-0057_fig_001" fig-type="figure" orientation="portrait" position="float"><label>Figure 1:</label><caption><p><text><SENT sid="88431" pm="."><plain>Flowchart of proposed methodology. </plain></SENT>
</text></p></caption><graphic xlink:href="jib-15-20170057-g001"/></fig></SecTag><sec id="j_jib-2017-0057_s_003_s_001"><label>3.1</label><title><text><SENT sid="88432" pm="."><plain>DNA Sequence Download </plain></SENT>
</text></title><p><text><SENT sid="88433" pm="."><plain>The ‘National Center for Biotechnology Information’ (NCBI) maintains a huge database of all the DNA and protein sequence data. </plain></SENT>
<SENT sid="88434" pm="."><plain>For the research project the ‘DENGUE’ DNA sequence with accession number “NC_001477” is retrieved from NCBI GenBank database using R and saved to a FASTA-format file using “write.fasta()” function. </plain></SENT>
</text></p></sec><sec id="j_jib-2017-0057_s_003_s_002"><label>3.2</label><title><text><SENT sid="88435" pm="."><plain>Pre-Processing </plain></SENT>
</text></title><p><text><SENT sid="88436" pm="."><plain>The saved FASTA-format file is then read using read.fasta() function in R environment. </plain></SENT>
<SENT sid="88437" pm="."><plain>The command reads the contents of the file into an R list object. </plain></SENT>
</text></p><p><text><SENT sid="88438" pm="."><plain>The length( ) function is used to obtain the length of the sequence and table( ) function is used to count the frequencies of the bases (a, c, g, t). </plain></SENT>
<SENT sid="88439" pm="."><plain>The R-queries to read and pre process the DNA sequence is given below. </plain></SENT>
</text></p><list list-type="order"><list-item id="j_jib-2017-0057_li_001"><p><text><SENT sid="88440" pm="."><plain>dengue ← read.fasta(file = “dengue.fasta”) </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_002"><p><text><SENT sid="88441" pm="."><plain>dengueSeq ← dengue[[1]] </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_003"><p><text><SENT sid="88442" pm="."><plain>length(dengueSeq) </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_004"><p><text><SENT sid="88443" pm="."><plain>table(dengueSeq) </plain></SENT>
</text></p></list-item></list></sec><sec id="j_jib-2017-0057_s_003_s_003"><label>3.3</label><title><text><SENT sid="88444" pm="."><plain>Extended Binary Tree Generation </plain></SENT>
</text></title><p><text><SENT sid="88445" pm="."><plain>Huffman tree is a full binary tree consisting of external and internal nodes. </plain></SENT>
<SENT sid="88446" pm="."><plain>Each internal node has exactly 2 children and each external node acts as a leaf. </plain></SENT>
<SENT sid="88447" pm="."><plain>The External nodes are labeled by the base characters in the sequence whereas the internal nodes are labeled by their frequencies or probabilities. </plain></SENT>
<SENT sid="88448" pm="."><plain>As a DNA sequence has only 4 bases (a, c, g, t) there will be 3 internal nodes and 4 external nodes in the tree. </plain></SENT>
<SENT sid="88449" pm="."><plain>The algorithm for generating an extended binary tree is given below and the generated binary tree is displayed in Figure 2. </plain></SENT>
</text></p><SecTag type="FIG"><fig id="j_jib-2017-0057_fig_002" fig-type="figure" orientation="portrait" position="float"><label>Figure 2:</label><caption><p><text><SENT sid="88450" pm="."><plain>Generated extended binary tree. </plain></SENT>
</text></p></caption><graphic xlink:href="jib-15-20170057-g002"/></fig></SecTag><p><text><SENT sid="88451" pm="."><plain>Algorithm </plain></SENT>
</text></p><list list-type="order"><list-item id="j_jib-2017-0057_li_005"><p><text><SENT sid="88452" pm="."><plain>START </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_006"><p><text><SENT sid="88453" pm="."><plain>Count the frequencies of each base in the DNA sequence. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_007"><p><text><SENT sid="88454" pm="."><plain>Find the max1, max2, max3, max4 frequency base from the sequence. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_008"><p><text><SENT sid="88455" pm="."><plain>Combine the two lowest frequencies bases as max3, max4; max2, (max3, max4); max1, (max2, (max3, max4)) to form a tree. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_009"><p><text><SENT sid="88456" pm="."><plain>Assign ‘0’ to maximum frequency base and ‘1’ to minimum frequency base of each pair of the generated tree as shown in Figure 2. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_010"><p><text><SENT sid="88457" pm="."><plain>Thus from Figure 2 max1 is assigned to 0, max2 is assigned to 10, max3 is assigned to 110 and max4 is assigned to 111. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_011"><p><text><SENT sid="88458" pm="."><plain>END </plain></SENT>
</text></p></list-item></list></sec><sec id="j_jib-2017-0057_s_003_s_004"><label>3.4</label><title><text><SENT sid="88459" pm="."><plain>Compression of the Sequence </plain></SENT>
</text></title><p><text><SENT sid="88460" pm="."><plain>To compress the DNA sequence, the bases are replaced by their respective codes generated from the tree. </plain></SENT>
<SENT sid="88461" pm="."><plain>Thus the compressed sequence is found. </plain></SENT>
<SENT sid="88462" pm="."><plain>But max1, max2, max3 and max4 bases are different for different sequences. </plain></SENT>
<SENT sid="88463" pm="."><plain>So, during decompression of the sequence, some clue must be given to identify them from the compressed sequence. </plain></SENT>
<SENT sid="88464" pm="."><plain>For this reason, six extra bits are added after the compressed sequence which can be accomplished in two steps. </plain></SENT>
</text></p><list list-type="order"><list-item id="j_jib-2017-0057_li_012"><p><text><SENT sid="88465" pm="."><plain>Globally assign a 2-bit binary number for each base like A = 00, C = 01, G = 10, T = 11. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_013"><p><text><SENT sid="88466" pm="."><plain>For max1, max2 and max3 base add the corresponding bits after the encrypted sequence in descending order to recognize which base has the maximum frequency. </plain></SENT>
</text></p></list-item></list><p><text><SENT sid="88467" pm="."><plain>Now save the encrypted sequence to get the compressed file. </plain></SENT>
<SENT sid="88468" pm="."><plain>The pseudo code of the proposed compression method is displayed below. </plain></SENT>
</text></p><p><text><SENT sid="88469" pm="."><plain>Pseudo Code </plain></SENT>
</text></p><list list-type="order"><list-item id="j_jib-2017-0057_li_014"><p><text><SENT sid="88470" pm="."><plain>START </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_015"><p><text><SENT sid="88471" pm="."><plain>Find max1, max2, max3, max4 frequency base. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_016"><p><text><SENT sid="88472" pm="."><plain>Replace max1 by 0, max2 by 10, max3 by 110 and max4 by 111. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_017"><p><text><SENT sid="88473" pm="."><plain>Assign A = 00, C = 01, G = 10, T = 11 in the code. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_018"><p><text><SENT sid="88474" pm="."><plain>Based on max1, max2, max3 base add the corresponding 6 bits from step 4, after the sequence found from step 3. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_019"><p><text><SENT sid="88475" pm="."><plain>Save the compressed sequence. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_020"><p><text><SENT sid="88476" pm="."><plain>END </plain></SENT>
</text></p></list-item></list><p><text><SENT sid="88477" pm="."><plain>In the ‘HuffBit Compress Algorithm’ always, ‘a’ is replaced by 0, ‘c’ is replaced by 10, ‘g’ is replaced by 110 and ‘t’ is replaced by 111. </plain></SENT>
<SENT sid="88478" pm="."><plain>Thus, if ‘g’ or ‘t’ becomes the maximum frequency base then the worst case compression ratio results because both ‘g’ and ‘t’ are replaced by 3 bits binary number. </plain></SENT>
<SENT sid="88479" pm="."><plain>To overcome this limitation, here a ‘Modified Huffbit Compress Algorithm’ is proposed. </plain></SENT>
<SENT sid="88480" pm="."><plain>The algorithm replaces the bases according to their frequency that is the max1 frequency base is replaced by a 1 bit binary number, the max2 base is replaced by a 2 bit binary number and the max3 and max4 bases are replaced by a 3 bit binary number. </plain></SENT>
<SENT sid="88481" pm="."><plain>So, the proposed algorithm will always achieve the best case compression ratio compared to the ‘HuffBit Compress Algorithm’. </plain></SENT>
<SENT sid="88482" pm="."><plain>In ‘Modified HuffBit Compress Algorithm’ 6 extra bits are also appended after the encrypted sequence which can be neglected for large sequences. </plain></SENT>
<SENT sid="88483" pm="."><plain>The proposed algorithm is implemented using R. </plain></SENT>
</text></p></sec><sec id="j_jib-2017-0057_s_003_s_005"><label>3.5</label><title><text><SENT sid="88484" pm="."><plain>Decompression of the Sequence </plain></SENT>
</text></title><p><text><SENT sid="88485" pm="."><plain>Decompression is important to get the original file from the compressed file. </plain></SENT>
<SENT sid="88486" pm="."><plain>The proposed algorithm is a lossless compression algorithm. </plain></SENT>
<SENT sid="88487" pm="."><plain>So, without losing any data the original file will be retrieved. </plain></SENT>
<SENT sid="88488" pm="."><plain>To decompress the previously compressed file, first it needs to be read in R environment. </plain></SENT>
<SENT sid="88489" pm="."><plain>Then we compare the last 6 bits with the assigned 2-bit number to detect max1, max2, max3 and max4 frequency base. </plain></SENT>
<SENT sid="88490" pm="."><plain>After finding the max1, max2, max3, max4 bases we remove the last 6 binary bits, then we replace 0 by the base which has the maximum frequency base (max1), replace 10 by the second maximum base (max2), replace 110 by the third maximum base (max3) and 111 by the minimum base (max4). </plain></SENT>
<SENT sid="88491" pm="."><plain>The sequence is now decompressed. </plain></SENT>
<SENT sid="88492" pm="."><plain>We write or save the sequence into a FASTA-format to get the original sequence back. </plain></SENT>
<SENT sid="88493" pm="."><plain>The pseudo code of the decompression method is depicted below. </plain></SENT>
</text></p><p><text><SENT sid="88494" pm="."><plain>Pseudo Code </plain></SENT>
</text></p><list list-type="order"><list-item id="j_jib-2017-0057_li_021"><p><text><SENT sid="88495" pm="."><plain>START </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_022"><p><text><SENT sid="88496" pm="."><plain>Compare last 6 bits with assigned binary number and get max1, max2, max3 and max4. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_023"><p><text><SENT sid="88497" pm="."><plain>Delete the last 6 bits. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_024"><p><text><SENT sid="88498" pm="."><plain>Replace 0 by max1 base, 10 by max2 base, 110 by max3 base and 111 by max4 base. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_025"><p><text><SENT sid="88499" pm="."><plain>Save the decompressed sequence. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_026"><p><text><SENT sid="88500" pm="."><plain>END </plain></SENT>
</text></p></list-item></list></sec><sec id="j_jib-2017-0057_s_003_s_006"><label>3.6</label><title><text><SENT sid="88501" pm="."><plain>Measurement of Compression Ratio with Examples </plain></SENT>
</text></title><p><text><SENT sid="88502" pm="."><plain>Compression ratio is denoted by, </plain></SENT>
</text></p><p><text><SENT sid="88503" pm="."><plain>(1)\documentclass[10pt]{article} \usepackage{wasysym} \usepackage[substack]{amsmath} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage[mathscr]{eucal} \usepackage{mathrsfs} \usepackage{pmc} \usepackage[Euler]{upgreek} \pagestyle{empty} \oddsidemargin -1.0in \begin{document} $${\text{Compression ratio}} = {\text{Number of bits encoded}}/{\text{Number of bases}}$$ \end{document} Compression ratio=Number of bits encoded/Number of bases </plain></SENT>
</text></p><p><text><SENT sid="88504" pm="."><plain>where, </plain></SENT>
</text></p><p><text><SENT sid="88505" pm="."><plain>(2)\documentclass[10pt]{article} \usepackage{wasysym} \usepackage[substack]{amsmath} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage[mathscr]{eucal} \usepackage{mathrsfs} \usepackage{pmc} \usepackage[Euler]{upgreek} \pagestyle{empty} \oddsidemargin -1.0in \begin{document} $${\text{Number of bits encoded}} = \sum\limits_{i = 1}^n {{\text{L}}(\text{b}) * F(\text{b}) + 6{\text{ bits}}}$$ \end{document} Number of bits encoded=∑i=1nL(b)∗F(b)+6 bits </plain></SENT>
</text></p><p><text><SENT sid="88506" pm="."><plain>Here, </plain></SENT>
</text></p><p><text><SENT sid="88507" pm="."><plain>L(b) = length of path in the tree (number of edges in the generated tree) from root to external node labeled i = 1 to max n = 3. </plain></SENT>
</text></p><p><text><SENT sid="88508" pm="."><plain>F(b) = Frequency of bases in the sequence. </plain></SENT>
</text></p><p><text><SENT sid="88509" pm="."><plain>The following three examples show the calculation procedure. </plain></SENT>
</text></p><statement content-type="example" id="j_jib-2017-0057_stat_001"><title><text><SENT sid="88510" pm="."><plain>Example 1 </plain></SENT>
</text></title><p><text><SENT sid="88511" pm="."><plain>Given, </plain></SENT>
</text></p><p><text><SENT sid="88512" pm="."><plain>\documentclass[10pt]{article} \usepackage{wasysym} \usepackage[substack]{amsmath} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage[mathscr]{eucal} \usepackage{mathrsfs} \usepackage{pmc} \usepackage[Euler]{upgreek} \pagestyle{empty} \oddsidemargin -1.0in \begin{document} $\eqalign{ {\text{Sequence}} &amp; = {\text{AAACTGAAGGGGTAAGAGAAGCAATAGGAAAA}} \cr &amp; {{\text{F}}_{\text{A}}}(\text{b}) = 17,{\text{ }}{{\text{F}}_{\text{G}}}(\text{b}) = 10,{\text{ }}{{\text{F}}_{\text{T}}}(\text{b}) = 3,{\text{ }}{{\text{F}}_{\text{C}}}(\text{b}) = 2 \cr}$ \end{document} Sequence=AAACTGAAGGGGTAAGAGAAGCAATAGGAAAAFA(b)=17, FG(b)=10, FT(b)=3, FC(b)=2 </plain></SENT>
</text></p><p><text><SENT sid="88513" pm="."><plain>Since, A is max1, G is max2, T is max3 and C is max4, a tree will be created according to the topic 3.3 by combining (T, C) then (G, (T, C)) and then (A, (G, (T, C))) as like Figure 3 and L(b) for A is 1(0), G is 2(10), T is 3(110) and C is 3(111). </plain></SENT>
</text></p><p><text><SENT sid="88514" pm="."><plain>From (2), </plain></SENT>
</text></p><p><text><SENT sid="88515" pm="."><plain>\documentclass[10pt]{article} \usepackage{wasysym} \usepackage[substack]{amsmath} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage[mathscr]{eucal} \usepackage{mathrsfs} \usepackage{pmc} \usepackage[Euler]{upgreek} \pagestyle{empty} \oddsidemargin -1.0in \begin{document} $$\eqalign{ {\text{Number of bits encoded}} &amp; = 1 \times 17 + 2 \times 10 + 3 \times 3 + 3 \times 2 + 6 \cr &amp; = 58{\text{ bits}} \cr}$$ \end{document} Number of bits encoded=1×17+2×10+3×3+3×2+6=58 bits </plain></SENT>
</text></p><p><text><SENT sid="88516" pm="."><plain>From (1), </plain></SENT>
</text></p><p><text><SENT sid="88517" pm="."><plain>\documentclass[10pt]{article} \usepackage{wasysym} \usepackage[substack]{amsmath} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage[mathscr]{eucal} \usepackage{mathrsfs} \usepackage{pmc} \usepackage[Euler]{upgreek} \pagestyle{empty} \oddsidemargin -1.0in \begin{document} $$\eqalign{ {\text{Compression ratio}} &amp; = 58/32{\text{ bits}}/{\text{base}} \cr &amp; = {\text{1}}{\text{.81 bits/base}} \cr}$$ \end{document} Compression ratio=58/32 bits/base=1.81 bits/base </plain></SENT>
</text></p><p><text><SENT sid="88518" pm="."><plain>Similar procedure is applied in Example 2 also. </plain></SENT>
</text></p></statement><SecTag type="FIG"><fig id="j_jib-2017-0057_fig_003" fig-type="figure" orientation="portrait" position="float"><label>Figure 3:</label><caption><p><text><SENT sid="88519" pm="."><plain>Generated tree for Example 1. </plain></SENT>
</text></p></caption><graphic xlink:href="jib-15-20170057-g003"/></fig></SecTag><statement content-type="example" id="j_jib-2017-0057_stat_002"><title><text><SENT sid="88520" pm="."><plain>Example 2 </plain></SENT>
</text></title><p><text><SENT sid="88521" pm="."><plain>Given sequence = ACTGCCCTTACCAGTCCTTTCA……………. </plain></SENT>
</text></p><p><text><SENT sid="88522" pm="."><plain>FC(b)=80, FT(b)=20, FA(b)=6, FG(b)=4 and L(b) for C is 1(0), T is 2(10), A is 3(110) and G is 3(111). </plain></SENT>
</text></p><p><text><SENT sid="88523" pm="."><plain>The generated tree for this sequence is shown in Figure 4. </plain></SENT>
</text></p><p><text><SENT sid="88524" pm="."><plain>From (2), </plain></SENT>
</text></p><p><text><SENT sid="88525" pm="."><plain>\documentclass[10pt]{article} \usepackage{wasysym} \usepackage[substack]{amsmath} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage[mathscr]{eucal} \usepackage{mathrsfs} \usepackage{pmc} \usepackage[Euler]{upgreek} \pagestyle{empty} \oddsidemargin -1.0in \begin{document} $$\eqalign{ {\text{Number of bits encoded}} &amp; = 1 \times 80 + 2 \times 20 + 3 \times 6 + 3 \times 4 + 6 \cr &amp; = 156{\text{ bits}} \cr}$$ \end{document} Number of bits encoded=1×80+2×20+3×6+3×4+6=156 bits </plain></SENT>
</text></p><p><text><SENT sid="88526" pm="."><plain>From (1), </plain></SENT>
</text></p><p><text><SENT sid="88527" pm="."><plain>\documentclass[10pt]{article} \usepackage{wasysym} \usepackage[substack]{amsmath} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage[mathscr]{eucal} \usepackage{mathrsfs} \usepackage{pmc} \usepackage[Euler]{upgreek} \pagestyle{empty} \oddsidemargin -1.0in \begin{document} $$\eqalign{ {\text{Compression ratio}} &amp; = 156/110{\text{ bits}}/{\text{base}} \cr &amp; = {\text{1}}{\text{.42 bits/base}} \cr}$$ \end{document} Compression ratio=156/110 bits/base=1.42 bits/base </plain></SENT>
</text></p></statement><SecTag type="FIG"><fig id="j_jib-2017-0057_fig_004" fig-type="figure" orientation="portrait" position="float"><label>Figure 4:</label><caption><p><text><SENT sid="88528" pm="."><plain>Generated tree for Example 2. </plain></SENT>
</text></p></caption><graphic xlink:href="jib-15-20170057-g004"/></fig></SecTag><statement content-type="example" id="j_jib-2017-0057_stat_003"><title><text><SENT sid="88529" pm="."><plain>Example 3 </plain></SENT>
</text></title><p><text><SENT sid="88530" pm="."><plain>\documentclass[10pt]{article} \usepackage{wasysym} \usepackage[substack]{amsmath} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage[mathscr]{eucal} \usepackage{mathrsfs} \usepackage{pmc} \usepackage[Euler]{upgreek} \pagestyle{empty} \oddsidemargin -1.0in \begin{document} $\eqalign{ &amp; {\text{Given sequence}} = {\text{GGGGACTTAACCGGGAGTAGC}} \ldots \cr &amp; {{\text{F}}_{\text{G}}}(\text{b}) = 800,{\text{ }}{{\text{F}}_{\text{A}}}(\text{b}) = 120,{\text{ }}{{\text{F}}_{\text{C}}}(\text{b}) = 60,{\text{ }}{{\text{F}}_{\text{T}}}(\text{b}) = 20{\text{ L(b) for G is }}1(0), \cr &amp; \quad {\text{A is }}2(10),{\text{ C is }}3(110){\text{ and T is }}3(111). \cr}$ \end{document} Given sequence=GGGGACTTAACCGGGAGTAGC…FG(b)=800, FA(b)=120, FC(b)=60, FT(b)=20 L(b) for G is 1(0),A is 2(10), C is 3(110) and T is 3(111). </plain></SENT>
</text></p><p><text><SENT sid="88531" pm="."><plain>The generated tree for this example is displayed in Figure 5. </plain></SENT>
</text></p><p><text><SENT sid="88532" pm="."><plain>From (2), </plain></SENT>
</text></p><p><text><SENT sid="88533" pm="."><plain>\documentclass[10pt]{article} \usepackage{wasysym} \usepackage[substack]{amsmath} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage[mathscr]{eucal} \usepackage{mathrsfs} \usepackage{pmc} \usepackage[Euler]{upgreek} \pagestyle{empty} \oddsidemargin -1.0in \begin{document} $$\eqalign{ {\text{Number of bits encoded}} &amp; = 1 \times 800 + 2 \times 120 + 3 \times 60 + 3 \times 20 + 6 \cr &amp; = 1286{\text{ bits}} \cr}$$ \end{document} Number of bits encoded=1×800+2×120+3×60+3×20+6=1286 bits </plain></SENT>
</text></p><p><text><SENT sid="88534" pm="."><plain>From (1), </plain></SENT>
</text></p><p><text><SENT sid="88535" pm="."><plain>\documentclass[10pt]{article} \usepackage{wasysym} \usepackage[substack]{amsmath} \usepackage{amsfonts} \usepackage{amssymb} \usepackage{amsbsy} \usepackage[mathscr]{eucal} \usepackage{mathrsfs} \usepackage{pmc} \usepackage[Euler]{upgreek} \pagestyle{empty} \oddsidemargin -1.0in \begin{document} $$\eqalign{ {\text{Compression ratio}} &amp; = 1286/1000{\text{ bits}}/{\text{base}} \cr &amp; = {\text{1}}{\text{.286 bits/base}} \cr}$$ \end{document} Compression ratio=1286/1000 bits/base=1.286 bits/base </plain></SENT>
</text></p></statement><SecTag type="FIG"><fig id="j_jib-2017-0057_fig_005" fig-type="figure" orientation="portrait" position="float"><label>Figure 5:</label><caption><p><text><SENT sid="88536" pm="."><plain>Generated tree for Example 3. </plain></SENT>
</text></p></caption><graphic xlink:href="jib-15-20170057-g005"/></fig></SecTag></sec></sec></SecTag><SecTag type="RESULTS"><sec id="j_jib-2017-0057_s_004"><label>4</label><title><text><SENT sid="88537" pm="."><plain>Result </plain></SENT>
</text></title><p><text><SENT sid="88538" pm="."><plain>The proposed DNA compression algorithm is a modified version of the original ‘HuffBit Compress Algorithm’ and is developed using R. The algorithm is designed to achieve the best case compression ratio always, compared to the ‘HuffBit Compress Algorithm’. </plain></SENT>
<SENT sid="88540" pm="."><plain>Several subsections are used here to describe the result of the proposed algorithm through 4.1 to 4.3. </plain></SENT>
</text></p><sec id="j_jib-2017-0057_s_004_s_001"><label>4.1</label><title><text><SENT sid="88541" pm="."><plain>Downloaded DNA Sequence </plain></SENT>
</text></title><p><text><SENT sid="88542" pm="."><plain>DNA sequence is a sequence with only four bases (a, c, g, t) of large numbers. </plain></SENT>
<SENT sid="88543" pm="."><plain>For this analysis ‘DENGUE’ DNA sequence is downloaded and saved in FASTA-format using R. The downloaded DNA sequence containing 10735 bases is then read in R for pre-processing and further analysis. </plain></SENT>
<SENT sid="88545" pm="."><plain>The top 630 bases of the sequence are displayed in Figure 6. </plain></SENT>
</text></p><SecTag type="FIG"><fig id="j_jib-2017-0057_fig_006" fig-type="figure" orientation="portrait" position="float"><label>Figure 6:</label><caption><p><text><SENT sid="88546" pm="."><plain>Top 630 bases of DENGUE DNA sequence using R. </plain></SENT>
</text></p></caption><graphic xlink:href="jib-15-20170057-g006"/></fig></SecTag></sec><sec id="j_jib-2017-0057_s_004_s_002"><label>4.2</label><title><text><SENT sid="88547" pm="."><plain>Pre-processing and Compression Method </plain></SENT>
</text></title><p><text><SENT sid="88548" pm="."><plain>Before starting the compression method, some operations must be performed on the DNA sequence such as finding out the length of the sequence; count the frequency of bases etc. </plain></SENT>
<SENT sid="88549" pm="."><plain>Then the compression method begins with findings of the max1, max2, max3 and max4 base and replacing them with the binary value generated from the extended binary tree. </plain></SENT>
<SENT sid="88550" pm="."><plain>Assigning A = 00, C = 01, G = 10 and T = 11 and at the last step appending 6 extra bits after the encrypted sequence. </plain></SENT>
</text></p><p><text><SENT sid="88551" pm="."><plain>Figure 7 displays the bottom of the compressed sequence. </plain></SENT>
<SENT sid="88552" pm="."><plain>From Figure 7, it is clearly viewed that each of the DNA sequence base is replaced by their corresponding code. </plain></SENT>
<SENT sid="88553" pm="."><plain>As each base is of 8 bits and each binary unit is of 1 bit, it is obvious that the file size will be reduced to a great extent after decompression. </plain></SENT>
<SENT sid="88554" pm="."><plain>In Figure 7, the last 6 bits are each of a 2 bits binary number. </plain></SENT>
<SENT sid="88555" pm="."><plain>Comparing these 6 bits with the assigned binary number a decision can be made in these ways </plain></SENT>
</text></p><SecTag type="FIG"><fig id="j_jib-2017-0057_fig_007" fig-type="figure" orientation="portrait" position="float"><label>Figure 7:</label><caption><p><text><SENT sid="88556" pm="."><plain>Bottom of the compressed sequence. </plain></SENT>
</text></p></caption><graphic xlink:href="jib-15-20170057-g007"/></fig></SecTag><list list-type="order"><list-item id="j_jib-2017-0057_li_027"><p><text><SENT sid="88557" pm="."><plain>The 1st 2 bits of the last 6 bits is 00. </plain></SENT>
<SENT sid="88558" pm="."><plain>A is assigned to 00. </plain></SENT>
<SENT sid="88559" pm="."><plain>So, ‘a’ is the max1 base. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_028"><p><text><SENT sid="88560" pm="."><plain>The 2nd 2 bits of the last 6 bits is 10. </plain></SENT>
<SENT sid="88561" pm="."><plain>G is assigned to 10. </plain></SENT>
<SENT sid="88562" pm="."><plain>So, ‘g’ is the max2 base. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_029"><p><text><SENT sid="88563" pm="."><plain>The 3rd 2 bits of the last 6 bits is 11. </plain></SENT>
<SENT sid="88564" pm="."><plain>T is assigned to 11. </plain></SENT>
<SENT sid="88565" pm="."><plain>So, ‘t’ is the max3 base. </plain></SENT>
</text></p></list-item><list-item id="j_jib-2017-0057_li_030"><p><text><SENT sid="88566" pm="."><plain>Now the remaining base which is ‘c’ is max4. </plain></SENT>
</text></p></list-item></list></sec><sec id="j_jib-2017-0057_s_004_s_003"><label>4.3</label><title><text><SENT sid="88567" pm="."><plain>Decompression Method </plain></SENT>
</text></title><p><text><SENT sid="88568" pm="."><plain>During decompression the binary codes will be replaced by their respective DNA bases. </plain></SENT>
<SENT sid="88569" pm="."><plain>For this reason, at first max1, max2, max3 and max4 base need to be identified. </plain></SENT>
<SENT sid="88570" pm="."><plain>To identify them, read the decompressed sequence in R and compare the last 6 bits of the sequence with the assigned binary bits. </plain></SENT>
<SENT sid="88571" pm="."><plain>Based on this comparison, find the max1, max2, max3 and max4 base of the sequence. </plain></SENT>
<SENT sid="88572" pm="."><plain>Then remove the last 6 binary bits and replace the binary codes with their corresponding bases such as, 0 by max1, 10 by max2, 110 by max3 and 111 by max4. </plain></SENT>
<SENT sid="88573" pm="."><plain>Thus the original DNA sequence will be found. </plain></SENT>
<SENT sid="88574" pm="."><plain>Save and store the sequence. </plain></SENT>
<SENT sid="88575" pm="."><plain>The decompressed sequence will look like the downloaded DNA sequence as in Figure 6. </plain></SENT>
</text></p></sec></sec></SecTag><SecTag type="DISCUSS"><sec id="j_jib-2017-0057_s_005"><label>5</label><title><text><SENT sid="88576" pm="."><plain>Discussion </plain></SENT>
</text></title><p><text><SENT sid="88577" pm="."><plain>In this section, Comparison of the proposed algorithm with previous algorithms (tree based) and complexity analysis of the proposed algorithm are shown through subsections 5.1 and 5.2. </plain></SENT>
</text></p><SecTag type="TABLE"></SecTag><p><text><SENT sid="88770" pm="."><plain>From Table 2, it is ensured that the time complexity of the proposed ‘Modified HuffBit Compress Algorithm’ is approximately same as ‘HuffBit Compress Algorithm’. </plain></SENT>
<SENT sid="88771" pm="."><plain>Also proposed algorithm always gives best case compression ratio than ‘HuffBit Compress Algorithm’. </plain></SENT>
<SENT sid="88772" pm="."><plain>So, using ‘Modified HuffBit Compress Algorithm’ will be more fruitful for DNA sequence compression. </plain></SENT>
</text></p></sec></sec></SecTag><SecTag type="CONCL"><sec id="j_jib-2017-0057_s_006"><label>6</label><title><text><SENT sid="88773" pm="."><plain>Conclusion </plain></SENT>
</text></title><p><text><SENT sid="88774" pm="."><plain>DNA compression is an important topic in bioinformatics which helps in storage, manipulation and transformation of large DNA sequences. </plain></SENT>
<SENT sid="88775" pm="."><plain>If the sequence is compressed using Modified HuffBit Compress algorithm, it will be easier to compress large bytes of DNA sequences with better compression ratio. </plain></SENT>
<SENT sid="88776" pm="."><plain>An advantage of the proposed algorithm is, it works well for large sequences. </plain></SENT>
<SENT sid="88777" pm="."><plain>So, it can be helpful to save storage problem greatly. </plain></SENT>
<SENT sid="88778" pm="."><plain>Moreover, it uses less time, memory and easy to implement using R. This research also creates a new dimension of using R in DNA compression which is the main potentiality of the research work. </plain></SENT>
<SENT sid="88780" pm="."><plain>The future work of the research is to overcome the limitations of the proposed algorithm and to come with a better outcome. </plain></SENT>
</text></p></sec></SecTag></body><back><SecTag type="ACK_FUND"><ack id="j_jib-2017-0057_ack_001"><title>Acknowledgments</title><p><text4fund><text><SENT sid="88781" pm="."><plain>The authors are grateful to the participants who contributed to this research. </plain></SENT>
<SENT sid="88782" pm="."><plain>No financial support is provided from any organization during the research project. </plain></SENT>
</text></text4fund></p></ack></SecTag><SecTag type="COMP_INT"><sec sec-type="COI-statement"><title>Conflict of interest statement</title><p>Authors state no conflict of interest. All authors have read the journal’s publication ethics and publication malpractice statement available at the journal’s website and hereby confirm that they comply with all its parts applicable to the present scientific work.</p></sec></SecTag><SecTag type="REF"><ref-list id="j_jib-2017-0057_reflist_001"><title>References</title><ref id="j_jib-2017-0057_ref_001"><text><SENT sid="88783" pm="."><plain>[1]PROGRAMIZAccessed Sepetember 19, 2017<ext-link ext-link-type="uri" xlink:href="https://www.programiz.com/r-programming">https://www.programiz.com/r-programming</ext-link> </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_002"><text><SENT sid="88784" pm="."><plain>[2]VanceAData analysts captivated by R’s PowerNY Times2009URL <ext-link ext-link-type="uri" xlink:href="http://www.nytimes.com/2009/01/07/technology/business-computing/07program.html?_r=1">http://www.nytimes.com/2009/01/07/technology/business-computing/07program.html?_r=1</ext-link> </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_003"><text><SENT sid="88785" pm="."><plain>[3]Timothy Prickett MorganOpen source R in commercial revolutionThe Register2010URL <ext-link ext-link-type="uri" xlink:href="http://www.theregister.co.uk/2010/05/06/revolution_commercial_r/">http://www.theregister.co.uk/2010/05/06/revolution_commercial_r/</ext-link> </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_004"><text><SENT sid="88786" pm="."><plain>[4]Genetics Home ReferenceAccessed March 15, 2017<ext-link ext-link-type="uri" xlink:href="https://ghr.nlm.nih.gov/primer/hgp/genome">https://ghr.nlm.nih.gov/primer/hgp/genome</ext-link> </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_005"><text><SENT sid="88787" pm="."><plain>[5]BhartiRKSinghRKA biological sequence compression based on look up table (LUT) using complementary palindrome of fixed sizeInt J Comput Appl20113509758887 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_006"><text><SENT sid="88788" pm="."><plain>[6]GrumbachSTahiFA new challenge for compression algorithms: genetic sequencesInf Process Manage19943087586 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_007"><text><SENT sid="88789" pm="."><plain>[7]GenomatixAccessed March 15, 2017<ext-link ext-link-type="uri" xlink:href="https://www.genomatix.de/online_help/help/sequence_formats.html">https://www.genomatix.de/online_help/help/sequence_formats.html</ext-link> </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_008"><text><SENT sid="88790" pm="."><plain>[8]GenBank and WGS Statistics (NCBI)Accessed March 15, 2017<ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/genbank/statistics/">https://www.ncbi.nlm.nih.gov/genbank/statistics/</ext-link> </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_009"><text><SENT sid="88791" pm="."><plain>[9]KooninEVThe emerging paradigm and open problems in comparative genomicsBioinformatics199915265610438229 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_010"><text><SENT sid="88792" pm="."><plain>[10]WooleyJCTrends in computational biology: a summary based on a RECOMB plenary lecture, 1999J Comput Biol20046459474 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_011"><text><SENT sid="88793" pm="."><plain>[11]BennettCHGacsPLiMVitanyiPMBZurekWHInformation DistanceIEEE Trans Inf Theory1998444 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_012"><text><SENT sid="88794" pm="."><plain>[12]RivalsEDelahayeJ-PDauchetMDelgrangeOA guaranteed compression scheme for repetitive DNA sequencesLIFL I University, technical report 1995; IT-285 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_013"><text><SENT sid="88795" pm="."><plain>[13]RajarajeswariPApparaoADNABIT compress – genome compression algorithmBioinformation201153506021383923 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_014"><text><SENT sid="88796" pm="."><plain>[14]GrumbachSTahiFCompression of DNA sequencesIEEE Symposium on the Data Compression Conference, DCC-93Snowbird, UT199334050 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_015"><text><SENT sid="88797" pm="."><plain>[15]ZivJLempelAA Universal Algorithm for Sequential Data CompressionIEEE Trans Inf Theory1977IT-23337 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_016"><text><SENT sid="88798" pm="."><plain>[16]ZIVJCoding Theorems for Individual SequencesIEEE Trans Inf Theory1978IT-24[PMID: 20157474] </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_017"><text><SENT sid="88799" pm="."><plain>[17]BakrNSSharawiAADNA lossless compression algorithms: reviewAm J Bioinform Res201337281 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_018"><text><SENT sid="88800" pm="."><plain>[18]BhartiRKHarbolaDState of the art: DNA compression algorithmsIJARCSSE20133397 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_019"><text><SENT sid="88801" pm="."><plain>[19]RivalsEDauchetMFast discerning repeats in DNA sequences with a compression algorithmThe 8th Workshop on Genome and Informatics, (GIW97)1997215268 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_020"><text><SENT sid="88802" pm="."><plain>[20]ChenXLiMMaBTrompJDNACompress: fast and effective DNA sequence compressionBioinformatics2002181696812490460 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_021"><text><SENT sid="88803" pm="."><plain>[21]MaBTrompJLiMPatternHunter – faster and more sensitive homology searchBioinformatics200218440511934743 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_022"><text><SENT sid="88804" pm="."><plain>[22]Raja RajeswariPApparaoAKiran KumarRHUFFBIT COMPRESS – algorithm to compress DNA sequences using extended binary treesJ Theor Appl Inf Technol2010131016 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_023"><text><SENT sid="88805" pm="."><plain>[23]GhoshdastiderUSahaBGenomeCompress: a novel algorithm for DNA compression2007 </plain></SENT>
</text></ref><ref id="j_jib-2017-0057_ref_024"><text><SENT sid="88806" pm="."><plain>[24]ComplexityAccessed August 17, 2017<ext-link ext-link-type="uri" xlink:href="http://www.dcs.gla.ac.uk/~pat/52233/complexity.html">http://www.dcs.gla.ac.uk/~pat/52233/complexity.html</ext-link> </plain></SENT>
</text></ref></ref-list></SecTag></back></article>
