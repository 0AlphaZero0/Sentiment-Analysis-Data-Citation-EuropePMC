<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD v1.1 20151215//EN" "JATS-archivearticle1.dtd"> 
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><?DTDIdentifier.IdentifierValue -//NLM//DTD JATS (Z39.96) Journal Publishing DTD v1.1 20151215//EN?><?DTDIdentifier.IdentifierType public?><?SourceDTD.DTDName JATS-journalpublishing1.dtd?><?SourceDTD.Version 1.1?><?ConverterInfo.XSLTName jp2nlmx2.xsl?><?ConverterInfo.Version 1?><front><journal-meta><journal-id journal-id-type="nlm-ta">J Integr Bioinform</journal-id><journal-id journal-id-type="iso-abbrev">J Integr Bioinform</journal-id><journal-id journal-id-type="publisher-id">jib</journal-id><journal-id journal-id-type="doi">jib</journal-id><journal-id journal-id-type="pmc">jib</journal-id><journal-title-group><journal-title>Journal of Integrative Bioinformatics</journal-title></journal-title-group><issn pub-type="epub">1613-4516</issn><publisher><publisher-name>De Gruyter</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">6340127</article-id><article-id pub-id-type="publisher-id">jib-2017-0057</article-id><article-id pub-id-type="doi">10.1515/jib-2017-0057</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Articles</subject></subj-group></article-categories><title-group><article-title>Modified HuffBit Compress Algorithm &#x02013; An Application of R</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes"><name><surname>Habib</surname><given-names>Nahida</given-names></name><email>nahidahabib164@yahoo.com</email><xref ref-type="aff" rid="j_jib-2017-0057_aff_001"/></contrib><contrib contrib-type="author"><name><surname>Ahmed</surname><given-names>Kawsar</given-names></name><xref ref-type="aff" rid="j_jib-2017-0057_aff_002"/></contrib><contrib contrib-type="author"><name><surname>Jabin</surname><given-names>Iffat</given-names></name><xref ref-type="aff" rid="j_jib-2017-0057_aff_003"/></contrib><contrib contrib-type="author"><name><surname>Rahman</surname><given-names>Mohammad Motiur</given-names></name><xref ref-type="aff" rid="j_jib-2017-0057_aff_003"/></contrib><aff id="j_jib-2017-0057_aff_001"><institution content-type="dept">Department of Computer Science and Engineering (CSE)</institution>, <institution>Mawlana Bhashani Science and Technology University (MBSTU)</institution>, <addr-line>Santosh</addr-line>, <city>Tangail 1902</city>, <country country="BD">Bangladesh</country></aff><aff id="j_jib-2017-0057_aff_002"><institution content-type="dept">Department of Information and Communication Technology (ICT)</institution>, <institution>Mawlana Bhashani Science and Technology University (MBSTU)</institution>, <city>Tangail</city>, <country country="BD">Bangladesh</country></aff><aff id="j_jib-2017-0057_aff_003"><institution content-type="dept">Department of Computer Science and Engineering (CSE)</institution>, <institution>Mawlana Bhashani Science and Technology University (MBSTU)</institution>, <city>Tangail</city>, <country country="BD">Bangladesh</country></aff></contrib-group><pub-date pub-type="epub"><day>22</day><month>2</month><year>2018</year></pub-date><pub-date pub-type="collection"><month>9</month><year>2018</year></pub-date><volume>15</volume><issue>3</issue><elocation-id seq="5">20170057</elocation-id><history><date date-type="received"><day>23</day><month>7</month><year>2017</year></date><date date-type="rev-recd"><day>02</day><month>1</month><year>2018</year></date><date date-type="accepted"><day>25</day><month>1</month><year>2018</year></date></history><permissions><copyright-statement>&#x000a9;2018 Nahida Habib et al., published by De Gruyter, Berlin/Boston</copyright-statement><copyright-year>2018</copyright-year><copyright-holder>Nahida Habib et al., published by De Gruyter, Berlin/Boston</copyright-holder><license license-type="open-access" specific-use="rights-object-archive-dnb" xlink:href="http://creativecommons.org/licenses/by-nc-nd/3.0"><license-p>This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivatives 3.0 License.</license-p></license></permissions><abstract><title>Abstract</title><p>The databases of genomic sequences are growing at an explicative rate because of the increasing growth of living organisms. Compressing deoxyribonucleic acid (DNA) sequences is a momentous task as the databases are getting closest to its threshold. Various compression algorithms are developed for DNA sequence compression. An efficient DNA compression algorithm that works on both repetitive and non-repetitive sequences known as &#x0201c;HuffBit Compress&#x0201d; is based on the concept of Extended Binary Tree. In this paper, here is proposed and developed a modified version of &#x0201c;HuffBit Compress&#x0201d; algorithm to compress and decompress DNA sequences using the R language which will always give the Best Case of the compression ratio but it uses extra 6 bits to compress than best case of &#x0201c;HuffBit Compress&#x0201d; algorithm and can be named as the &#x0201c;Modified HuffBit Compress Algorithm&#x0201d;. The algorithm makes an extended binary tree based on the Huffman Codes and the maximum occurring bases (A, C, G, T). Experimenting with 6 sequences the proposed algorithm gives approximately 16.18&#x02009;% improvement in compression ration over the &#x0201c;HuffBit Compress&#x0201d; algorithm and 11.12&#x02009;% improvement in compression ration over the &#x0201c;2-Bits Encoding Method&#x0201d;.</p></abstract><kwd-group><title>Keywords</title><kwd>Compression and Decompression</kwd><kwd>Compression Ratio</kwd><kwd>Extended Binary Tree</kwd><kwd>HuffBit Compress</kwd><kwd>2-Bits Encoding Method</kwd></kwd-group><counts><fig-count count="7"/><table-count count="2"/><ref-count count="24"/><page-count count="13"/></counts></article-meta></front><body><sec id="j_jib-2017-0057_s_001"><label>1</label><title>Introduction</title><p>R is one of the most popular languages used by statisticians, data analysts, researchers and marketers to retrieve, clean, analyze, visualize and present data [<xref rid="j_jib-2017-0057_ref_001" ref-type="bibr">1</xref>]. It is an interactive environment providing a wide variety of statistical and graphical techniques. The R tool has become more popular among statisticians, mathematicians, computer scientists and researchers because of its excessive number of libraries and packages and ease of use. The R tool can also be applied in genetic applications. It is an implementation of the S programming language and has an estimated two million users [<xref rid="j_jib-2017-0057_ref_002" ref-type="bibr">2</xref>], [<xref rid="j_jib-2017-0057_ref_003" ref-type="bibr">3</xref>].</p><p>The genome contains all of the information needed to build and maintain an organism. In humans, a copy of the entire genome &#x02013; more than 3 billion deoxyribonucleic acid (DNA) base pairs &#x02013; is contained in all cells that have a nucleus [<xref rid="j_jib-2017-0057_ref_004" ref-type="bibr">4</xref>] and more than 99&#x02009;% pairs are the same in all humans [<xref rid="j_jib-2017-0057_ref_005" ref-type="bibr">5</xref>]. A DNA chain is made of four bases: adenine (A), guanine (G), thymine (T) and cytosine (C). These four chemical bases always bond with the same co-partner to comprise base pairs. For a complete genome a DNA sequence can be represented as a very long text containing only the bases (A, C, G, T) [<xref rid="j_jib-2017-0057_ref_006" ref-type="bibr">6</xref>].</p><p>A text-based format known as FASTA format can be used to represent or store a DNA sequence. Some other formats include Plain sequence format, FASTQ format, EMBL format, GCG format, GCG-RSF format, GenBank format and IG format [<xref rid="j_jib-2017-0057_ref_007" ref-type="bibr">7</xref>].</p><p>Thousands of nucleotides are sequenced every day. From 1982 to the present, the number of bases in GenBank has doubled approximately every 18 months [<xref rid="j_jib-2017-0057_ref_008" ref-type="bibr">8</xref>]. Approximately 228719437638 bases are there in the GenBank database in February 2017 [<xref rid="j_jib-2017-0057_ref_008" ref-type="bibr">8</xref>]. As a result, it becomes very hard to maintain, process, and store the large dataset in the database. Again, finding the characteristics and comparing Genomes is a major task [<xref rid="j_jib-2017-0057_ref_009" ref-type="bibr">9</xref>], [<xref rid="j_jib-2017-0057_ref_010" ref-type="bibr">10</xref>]. So it is clear that, DNA sequences should be compressible which is an analytical method created by bioinformatics.</p><p>Biological sequence compression is an effective apparatus to extract information from biological sequences. With respect to computer science data compression stands for curtailment of the size of memory used to store a data. From a mathematical point of view, compression implies better understanding and comprehension [<xref rid="j_jib-2017-0057_ref_011" ref-type="bibr">11</xref>]. The compression of DNA sequences is not an easy task [<xref rid="j_jib-2017-0057_ref_006" ref-type="bibr">6</xref>], [<xref rid="j_jib-2017-0057_ref_012" ref-type="bibr">12</xref>]. General purpose compression algorithms fail to perform well with biological sequences. Most of the Existing software tools worked well for English text compression [<xref rid="j_jib-2017-0057_ref_013" ref-type="bibr">13</xref>] but not for DNA Genomes. Lossless and lossy are two compression techniques. In lossless compression all of the information is completely restored after decompression. While in the lossy technique, we loss some of the data and do not recover the complete original data after decompression.</p><p>The proposed research is a lossless compression algorithm which builds an Extended Binary Tree for DNA sequences by assigning binary codes (0 and 1) to each base to compress both repetitive and non-repetitive DNA sequences. The algorithm is implemented using R. This paper is organized in 6 sections. Section <xref ref-type="sec" rid="j_jib-2017-0057_s_002">2</xref> presents the background and previous work related to the research, Section <xref ref-type="sec" rid="j_jib-2017-0057_s_003">3</xref> describes the proposed methodology and working principle, Section <xref ref-type="sec" rid="j_jib-2017-0057_s_004">4</xref> presents the results, Section <xref ref-type="sec" rid="j_jib-2017-0057_s_005">5</xref> discusses and analyzes the results, and last but not least Section <xref ref-type="sec" rid="j_jib-2017-0057_s_006">6</xref> includes conclusion and future work.</p></sec><sec id="j_jib-2017-0057_s_002"><label>2</label><title>Related Work</title><p>Due to not using special structures of biological sequences, the standard compression techniques cannot compress the biological sequences well. Recently, several algorithms have been proposed for the compression of DNA sequences based on DNA sequence special structures. Two lossless compression algorithms named BioCompress [<xref rid="j_jib-2017-0057_ref_014" ref-type="bibr">14</xref>] and BioCompress-2 [<xref rid="j_jib-2017-0057_ref_006" ref-type="bibr">6</xref>] were proposed by Grumbach and Tahi. These algorithms were based on Ziv and Lempel data compression method [<xref rid="j_jib-2017-0057_ref_015" ref-type="bibr">15</xref>], [<xref rid="j_jib-2017-0057_ref_016" ref-type="bibr">16</xref>]. They search the previously processed part of the sequence for repeats. BioCompress-2 is the extended version of BioCompress which uses the arithmetic coding of order 2 if no significant repetition is found. The results showed that both algorithms compressed the standard benchmark data with an average compression ratio of 1.850 bpb for Biocompress and 1.783 bpb for Biocompress 2 [<xref rid="j_jib-2017-0057_ref_017" ref-type="bibr">17</xref>]. Decompression may demean the algorithm performance, as it requires reference to the starting of the sequence which requires more memory reference [<xref rid="j_jib-2017-0057_ref_018" ref-type="bibr">18</xref>].</p><p>The Cfact [<xref rid="j_jib-2017-0057_ref_019" ref-type="bibr">19</xref>] used a two-pass algorithm to search for the longest exact and reverse complement repeats. It builds the suffix tree of the sequence and then encodes using LZ. Non-repeat regions are also encoded by 2 bpb. There are no compression results about this algorithm; therefore it is difficult to compare [<xref rid="j_jib-2017-0057_ref_017" ref-type="bibr">17</xref>]. It works similar to Biocompress, but takes more compression time, since it uses two passes, and constructs a suffix tree.</p><p>GenCompress is a one pass algorithm which is based on LZ77. This algorithm carefully finds the optimal prefix and uses order-2 arithmetic encoding whenever needed [<xref rid="j_jib-2017-0057_ref_013" ref-type="bibr">13</xref>]. It searches for both approximate matches and the approximate complimented palindrome. There are two versions of GenCompress: GenCompress-1 uses the Hamming distance with replacement or substitution operations only. GenCompress-2 uses edit distance based on the insert and delete operation. GenCompress achieves 1.742 bpb which is a higher compression ratio compared to BioCompress-2 [<xref rid="j_jib-2017-0057_ref_017" ref-type="bibr">17</xref>].</p><p>DNACompress [<xref rid="j_jib-2017-0057_ref_020" ref-type="bibr">20</xref>] is the modified algorithm of GenCompress which is a two-pass algorithm. It also uses Lempel-Ziv compression scheme which finds all the approximate repeats including complemented palindromes using a software tool called Pattern Hunter [<xref rid="j_jib-2017-0057_ref_021" ref-type="bibr">21</xref>]. It encrypts approximate repeat and non-repeat regions. DNACompress was able to deal with large sequences (e.g. <italic>E. coli</italic> with about 4.6 Megabases) in about a minute, where GenCompress required nearly about half an hour [<xref rid="j_jib-2017-0057_ref_017" ref-type="bibr">17</xref>]. This algorithm achieves a compression rate of 1.72 bpb.</p><p>Huffman coding or 2 Bits Encoding Method is based on building a binary tree according to the bases frequencies. Each base is represented by 2 bits and assigned as A&#x02009;=&#x02009;00, C&#x02009;=&#x02009;01, G&#x02009;=&#x02009;10, T&#x02009;=&#x02009;11. As a result, it requires 2400 bits of space when the sequence length is 1200. That is, the storage of encoded sequence is almost the double of its original sequence length [<xref rid="j_jib-2017-0057_ref_006" ref-type="bibr">6</xref>].</p><p>HuffBit Compress Algorithm [<xref rid="j_jib-2017-0057_ref_022" ref-type="bibr">22</xref>] uses the concept of extended binary trees for compression. It assigns a zero for left child and one for right child. It is a two way process; in the initial phase it constructs an extended binary tree then replaces the sequences using the codes generated from the tree. The algorithm replaces a, c, g, t by a constant binary value where a is replaced by 0, c is replaced by 10, g is replaced by 110 and t is replaced by 111. It achieves a compression ratio of 1.006 bpb for the best case, 1.611 bpb for the average case, and 2.109 bpb for the worst case. In most of the cases it fails to achieve the best case compression ratio.</p><p>From the above discussion, it is clear that day by day research work on compressing DNA sequences is increasing and each algorithm comes with a better compression ratio. Each descendant algorithm comes reducing the disadvantages of previous algorithms. For example, BioCompress 2 gives better compression ratio than BioCompress1 but the storage complexity of them are high. Again, GenCompress gives better compression ratio than BioCompress2 but takes more time for large sequence compared to DNACompress. Cfact is more complex in case of time. Huffman coding has a problem of storage complexity. For worst case Huffbit Compress compression ratio is not satisfactory. In this article, it has been tried to achieve a better compression factor than existing compression programs using the repeat and non-repeat sequence. Moreover, the proposed algorithm is simple, easy to implement, takes less memory space and most of the cases gives better compression ratio than HuffBit Compress Algorithm and 2 Bits Encoding Method.</p></sec><sec id="j_jib-2017-0057_s_003"><label>3</label><title>Proposed Methodology</title><p>The proposed algorithm works on two phases. In the first phase it uses Huffman code to generate an extended binary tree based on the frequencies of the bases. In the second phase, each base is replaced by its corresponding binary bits generated from the tree. Compression and decompression of the DNA sequences are performed using R. Several steps are performed in this manner as described in the subsections through 3.1 to 3.6. A flowchart showing the proposed methodology including compression and decompression method is noticed in Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_001">1</xref>.</p><fig id="j_jib-2017-0057_fig_001" fig-type="figure" orientation="portrait" position="float"><label>Figure 1:</label><caption><p>Flowchart of proposed methodology.</p></caption><graphic xlink:href="jib-15-20170057-g001"/></fig><sec id="j_jib-2017-0057_s_003_s_001"><label>3.1</label><title>DNA Sequence Download</title><p>The &#x02018;National Center for Biotechnology Information&#x02019; (NCBI) maintains a huge database of all the DNA and protein sequence data. For the research project the &#x02018;DENGUE&#x02019; DNA sequence with accession number &#x0201c;NC_001477&#x0201d; is retrieved from NCBI GenBank database using R and saved to a FASTA-format file using &#x0201c;write.fasta()&#x0201d; function.</p></sec><sec id="j_jib-2017-0057_s_003_s_002"><label>3.2</label><title>Pre-Processing</title><p>The saved FASTA-format file is then read using read.fasta() function in R environment. The command reads the contents of the file into an R list object.</p><p>The length( ) function is used to obtain the length of the sequence and table( ) function is used to count the frequencies of the bases (a, c, g, t). The R-queries to read and pre process the DNA sequence is given below.</p><list list-type="order"><list-item id="j_jib-2017-0057_li_001"><p>dengue&#x02009;&#x02190;&#x02009;read.fasta(file&#x02009;=&#x02009;&#x0201c;dengue.fasta&#x0201d;)</p></list-item><list-item id="j_jib-2017-0057_li_002"><p>dengueSeq&#x02009;&#x02190;&#x02009;dengue[[1]]</p></list-item><list-item id="j_jib-2017-0057_li_003"><p>length(dengueSeq)</p></list-item><list-item id="j_jib-2017-0057_li_004"><p>table(dengueSeq)</p></list-item></list></sec><sec id="j_jib-2017-0057_s_003_s_003"><label>3.3</label><title>Extended Binary Tree Generation</title><p>Huffman tree is a full binary tree consisting of external and internal nodes. Each internal node has exactly 2 children and each external node acts as a leaf. The External nodes are labeled by the base characters in the sequence whereas the internal nodes are labeled by their frequencies or probabilities. As a DNA sequence has only 4 bases (a, c, g, t) there will be 3 internal nodes and 4 external nodes in the tree. The algorithm for generating an extended binary tree is given below and the generated binary tree is displayed in Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_002">2</xref>.</p><fig id="j_jib-2017-0057_fig_002" fig-type="figure" orientation="portrait" position="float"><label>Figure 2:</label><caption><p>Generated extended binary tree.</p></caption><graphic xlink:href="jib-15-20170057-g002"/></fig><p>
<bold>Algorithm</bold>
</p><list list-type="order"><list-item id="j_jib-2017-0057_li_005"><p>START</p></list-item><list-item id="j_jib-2017-0057_li_006"><p>Count the frequencies of each base in the DNA sequence.</p></list-item><list-item id="j_jib-2017-0057_li_007"><p>Find the max1, max2, max3, max4 frequency base from the sequence.</p></list-item><list-item id="j_jib-2017-0057_li_008"><p>Combine the two lowest frequencies bases as max3, max4; max2, (max3, max4); max1, (max2, (max3, max4)) to form a tree.</p></list-item><list-item id="j_jib-2017-0057_li_009"><p>Assign &#x02018;0&#x02019; to maximum frequency base and &#x02018;1&#x02019; to minimum frequency base of each pair of the generated tree as shown in Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_002">2</xref>.</p></list-item><list-item id="j_jib-2017-0057_li_010"><p>Thus from Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_002">2</xref> max1 is assigned to 0, max2 is assigned to 10, max3 is assigned to 110 and max4 is assigned to 111.</p></list-item><list-item id="j_jib-2017-0057_li_011"><p>END</p></list-item></list></sec><sec id="j_jib-2017-0057_s_003_s_004"><label>3.4</label><title>Compression of the Sequence</title><p>To compress the DNA sequence, the bases are replaced by their respective codes generated from the tree. Thus the compressed sequence is found. But max1, max2, max3 and max4 bases are different for different sequences. So, during decompression of the sequence, some clue must be given to identify them from the compressed sequence. For this reason, six extra bits are added after the compressed sequence which can be accomplished in two steps.</p><list list-type="order"><list-item id="j_jib-2017-0057_li_012"><p>Globally assign a 2-bit binary number for each base like A&#x02009;=&#x02009;00, C&#x02009;=&#x02009;01, G&#x02009;=&#x02009;10, T&#x02009;=&#x02009;11.</p></list-item><list-item id="j_jib-2017-0057_li_013"><p>For max1, max2 and max3 base add the corresponding bits after the encrypted sequence in descending order to recognize which base has the maximum frequency.</p></list-item></list><p>Now save the encrypted sequence to get the compressed file. The pseudo code of the proposed compression method is displayed below.</p><p>
<bold>Pseudo Code</bold>
</p><list list-type="order"><list-item id="j_jib-2017-0057_li_014"><p>START</p></list-item><list-item id="j_jib-2017-0057_li_015"><p>Find max1, max2, max3, max4 frequency base.</p></list-item><list-item id="j_jib-2017-0057_li_016"><p>Replace max1 by 0, max2 by 10, max3 by 110 and max4 by 111.</p></list-item><list-item id="j_jib-2017-0057_li_017"><p>Assign A&#x02009;=&#x02009;00, C&#x02009;=&#x02009;01, G&#x02009;=&#x02009;10, T&#x02009;=&#x02009;11 in the code.</p></list-item><list-item id="j_jib-2017-0057_li_018"><p>Based on max1, max2, max3 base add the corresponding 6 bits from step 4, after the sequence found from step 3.</p></list-item><list-item id="j_jib-2017-0057_li_019"><p>Save the compressed sequence.</p></list-item><list-item id="j_jib-2017-0057_li_020"><p>END</p></list-item></list><p>In the &#x02018;HuffBit Compress Algorithm&#x02019; always, &#x02018;a&#x02019; is replaced by 0, &#x02018;c&#x02019; is replaced by 10, &#x02018;g&#x02019; is replaced by 110 and &#x02018;t&#x02019; is replaced by 111. Thus, if &#x02018;g&#x02019; or &#x02018;t&#x02019; becomes the maximum frequency base then the worst case compression ratio results because both &#x02018;g&#x02019; and &#x02018;t&#x02019; are replaced by 3 bits binary number. To overcome this limitation, here a &#x02018;Modified Huffbit Compress Algorithm&#x02019; is proposed. The algorithm replaces the bases according to their frequency that is the max1 frequency base is replaced by a 1 bit binary number, the max2 base is replaced by a 2 bit binary number and the max3 and max4 bases are replaced by a 3 bit binary number. So, the proposed algorithm will always achieve the best case compression ratio compared to the &#x02018;HuffBit Compress Algorithm&#x02019;. In &#x02018;Modified HuffBit Compress Algorithm&#x02019; 6 extra bits are also appended after the encrypted sequence which can be neglected for large sequences. The proposed algorithm is implemented using R.</p></sec><sec id="j_jib-2017-0057_s_003_s_005"><label>3.5</label><title>Decompression of the Sequence</title><p>Decompression is important to get the original file from the compressed file. The proposed algorithm is a lossless compression algorithm. So, without losing any data the original file will be retrieved. To decompress the previously compressed file, first it needs to be read in R environment. Then we compare the last 6 bits with the assigned 2-bit number to detect max1, max2, max3 and max4 frequency base. After finding the max1, max2, max3, max4 bases we remove the last 6 binary bits, then we replace 0 by the base which has the maximum frequency base (max1), replace 10 by the second maximum base (max2), replace 110 by the third maximum base (max3) and 111 by the minimum base (max4). The sequence is now decompressed. We write or save the sequence into a FASTA-format to get the original sequence back. The pseudo code of the decompression method is depicted below.</p><p>
<bold>Pseudo Code</bold>
</p><list list-type="order"><list-item id="j_jib-2017-0057_li_021"><p>START</p></list-item><list-item id="j_jib-2017-0057_li_022"><p>Compare last 6 bits with assigned binary number and get max1, max2, max3 and max4.</p></list-item><list-item id="j_jib-2017-0057_li_023"><p>Delete the last 6 bits.</p></list-item><list-item id="j_jib-2017-0057_li_024"><p>Replace 0 by max1 base, 10 by max2 base, 110 by max3 base and 111 by max4 base.</p></list-item><list-item id="j_jib-2017-0057_li_025"><p>Save the decompressed sequence.</p></list-item><list-item id="j_jib-2017-0057_li_026"><p>END</p></list-item></list></sec><sec id="j_jib-2017-0057_s_003_s_006"><label>3.6</label><title>Measurement of Compression Ratio with Examples</title><p>Compression ratio is denoted by,</p><p>
<disp-formula id="j_jib-2017-0057-e001"><label>(1)</label><alternatives><tex-math id="M1">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$${\text{Compression ratio}} = {\text{Number of bits encoded}}/{\text{Number of bases}}$$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_001"><mml:mrow><mml:mtext>Compression ratio</mml:mtext></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mtext>Number of bits encoded</mml:mtext></mml:mrow><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mrow><mml:mtext>Number of bases</mml:mtext></mml:mrow></mml:math><graphic xlink:href="jib-15-20170057-e001.jpg" position="float" orientation="portrait"/></alternatives></disp-formula>
</p><p>where,</p><p>
<disp-formula id="j_jib-2017-0057-e002"><label>(2)</label><alternatives><tex-math id="M2">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$${\text{Number of bits encoded}} = \sum\limits_{i = 1}^n {{\text{L}}(\text{b}) * F(\text{b}) + 6{\text{ bits}}}$$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_002"><mml:mrow><mml:mtext>Number of bits encoded</mml:mtext></mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo movablelimits="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:mtext>L</mml:mtext></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>b</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02217;</mml:mo><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mtext>b</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>6</mml:mn><mml:mrow><mml:mtext> bits</mml:mtext></mml:mrow></mml:mrow></mml:math><graphic xlink:href="jib-15-20170057-e002.jpg" position="float" orientation="portrait"/></alternatives></disp-formula>
</p><p>Here,</p><p>L(b)&#x02009;=&#x02009;length of path in the tree (number of edges in the generated tree) from root to external node labeled <italic>i</italic>&#x02009;=&#x02009;1 to max <italic>n</italic>&#x02009;=&#x02009;3.</p><p>F(b)&#x02009;=&#x02009;Frequency of bases in the sequence.</p><p>The following three examples show the calculation procedure.</p><statement content-type="example" id="j_jib-2017-0057_stat_001"><title>Example 1</title><p>Given,</p><p>
<inline-formula id="j_jib-2017-0057-i003"><alternatives><tex-math id="M3">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$\eqalign{ {\text{Sequence}} &#x00026; = {\text{AAACTGAAGGGGTAAGAGAAGCAATAGGAAAA}}  \cr &#x00026; {{\text{F}}_{\text{A}}}(\text{b}) = 17,{\text{ }}{{\text{F}}_{\text{G}}}(\text{b}) = 10,{\text{ }}{{\text{F}}_{\text{T}}}(\text{b}) = 3,{\text{ }}{{\text{F}}_{\text{C}}}(\text{b}) = 2 \cr}$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_003"><mml:mtable columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mml:mtr><mml:mtd/><mml:mtd><mml:mrow><mml:mtext>Sequence</mml:mtext></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mtext>AAACTGAAGGGGTAAGAGAAGCAATAGGAAAA</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mtext>F</mml:mtext></mml:mrow><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>b</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>17</mml:mn><mml:mo>,</mml:mo><mml:mrow><mml:mtext>
</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>F</mml:mtext></mml:mrow><mml:mrow><mml:mtext>G</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>b</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>10</mml:mn><mml:mo>,</mml:mo><mml:mrow><mml:mtext>&#x02009;</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>F</mml:mtext></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>b</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:mo>,</mml:mo><mml:mrow><mml:mtext>&#x02009;</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>F</mml:mtext></mml:mrow><mml:mrow><mml:mtext>C</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>b</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:math><inline-graphic xlink:href="jib-15-20170057-i001.jpg"/></alternatives></inline-formula>
</p><p>Since, A is max1, G is max2, T is max3 and C is max4, a tree will be created according to the topic 3.3 by combining (T, C) then (G, (T, C)) and then (A, (G, (T, C))) as like Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_003">3</xref> and L(b) for A is 1(0), G is 2(10), T is 3(110) and C is 3(111).</p><p>From (<xref ref-type="disp-formula" rid="j_jib-2017-0057-e002">2</xref>),</p><p>
<disp-formula id="j_jib-2017-0057-e003"><alternatives><tex-math id="M4">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$$\eqalign{ {\text{Number of bits encoded}} &#x00026; =   1 \times 17 + 2 \times 10 + 3 \times 3 + 3 \times 2 + 6 \cr &#x00026; =  58{\text{ bits}} \cr}$$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_004"><mml:mtable columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mml:mtr><mml:mtd><mml:mrow><mml:mtext>Number of bits encoded</mml:mtext></mml:mrow><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mn>1</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>17</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>10</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>3</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>2</mml:mn><mml:mo>+</mml:mo><mml:mn>6</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mn>58</mml:mn><mml:mrow><mml:mtext>&#x02009;bits</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="jib-15-20170057-e003.jpg" position="float" orientation="portrait"/></alternatives></disp-formula>
</p><p>From (<xref ref-type="disp-formula" rid="j_jib-2017-0057-e001">1</xref>),</p><p>
<disp-formula id="j_jib-2017-0057-e004"><alternatives><tex-math id="M5">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$$\eqalign{ {\text{Compression ratio}} &#x00026; =   58/32{\text{ bits}}/{\text{base}} \cr &#x00026; =   {\text{1}}{\text{.81 bits/base}} \cr}$$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_005"><mml:mtable columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mml:mtr><mml:mtd><mml:mrow><mml:mtext>Compression ratio</mml:mtext></mml:mrow><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mn>58</mml:mn><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>32</mml:mn><mml:mrow><mml:mtext>&#x02009;bits</mml:mtext></mml:mrow><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mrow><mml:mtext>base</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow><mml:mrow><mml:mtext>.81 bits/base</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="jib-15-20170057-e004.jpg" position="float" orientation="portrait"/></alternatives></disp-formula>
</p><p>Similar procedure is applied in <xref ref-type="statement" rid="j_jib-2017-0057_stat_002">Example 2</xref> also.</p></statement><fig id="j_jib-2017-0057_fig_003" fig-type="figure" orientation="portrait" position="float"><label>Figure 3:</label><caption><p>Generated tree for <xref ref-type="statement" rid="j_jib-2017-0057_stat_001">Example 1</xref>.</p></caption><graphic xlink:href="jib-15-20170057-g003"/></fig><statement content-type="example" id="j_jib-2017-0057_stat_002"><title>Example 2</title><p>Given sequence = ACTGCCCTTACCAGTCCTTTCA&#x02026;&#x02026;&#x02026;&#x02026;&#x02026;.</p><p>F<sub>C</sub>(b)=80, F<sub>T</sub>(b)=20, F<sub>A</sub>(b)=6, F<sub>G</sub>(b)=4 and L(b) for C is 1(0), T is 2(10), A is 3(110) and G is 3(111).</p><p>The generated tree for this sequence is shown in Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_004">4</xref>.</p><p>From (<xref ref-type="disp-formula" rid="j_jib-2017-0057-e002">2</xref>),</p><p>
<disp-formula id="j_jib-2017-0057-e005"><alternatives><tex-math id="M6">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$$\eqalign{ {\text{Number of bits encoded}} &#x00026; =   1 \times 80 + 2 \times 20 + 3 \times 6 + 3 \times 4 + 6 \cr &#x00026; =  156{\text{ bits}} \cr}$$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_006"><mml:mtable columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mml:mtr><mml:mtd><mml:mrow><mml:mtext>Number of bits encoded</mml:mtext></mml:mrow><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mn>1</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>80</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>20</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>6</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>4</mml:mn><mml:mo>+</mml:mo><mml:mn>6</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mn>156</mml:mn><mml:mrow><mml:mtext>&#x02009;bits</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="jib-15-20170057-e005.jpg" position="float" orientation="portrait"/></alternatives></disp-formula>
</p><p>From (<xref ref-type="disp-formula" rid="j_jib-2017-0057-e001">1</xref>),</p><p>
<disp-formula id="j_jib-2017-0057-e006"><alternatives><tex-math id="M7">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$$\eqalign{ {\text{Compression ratio}} &#x00026; =   156/110{\text{ bits}}/{\text{base}} \cr &#x00026; =   {\text{1}}{\text{.42 bits/base}} \cr}$$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_007"><mml:mtable columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mml:mtr><mml:mtd><mml:mrow><mml:mtext>Compression ratio</mml:mtext></mml:mrow><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mn>156</mml:mn><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>110</mml:mn><mml:mrow><mml:mtext>&#x02009;bits</mml:mtext></mml:mrow><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mrow><mml:mtext>base</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow><mml:mrow><mml:mtext>.42 bits/base</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="jib-15-20170057-e006.jpg" position="float" orientation="portrait"/></alternatives></disp-formula>
</p></statement><fig id="j_jib-2017-0057_fig_004" fig-type="figure" orientation="portrait" position="float"><label>Figure 4:</label><caption><p>Generated tree for <xref ref-type="statement" rid="j_jib-2017-0057_stat_002">Example 2</xref>.</p></caption><graphic xlink:href="jib-15-20170057-g004"/></fig><statement content-type="example" id="j_jib-2017-0057_stat_003"><title>Example 3</title><p>
<inline-formula id="j_jib-2017-0057-i001"><alternatives><tex-math id="M8">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$\eqalign{ &#x00026; {\text{Given sequence}} = {\text{GGGGACTTAACCGGGAGTAGC}} \ldots   \cr &#x00026; {{\text{F}}_{\text{G}}}(\text{b}) = 800,{\text{ }}{{\text{F}}_{\text{A}}}(\text{b}) = 120,{\text{ }}{{\text{F}}_{\text{C}}}(\text{b}) = 60,{\text{ }}{{\text{F}}_{\text{T}}}(\text{b}) = 20{\text{ L(b) for G is }}1(0),  \cr &#x00026; \quad {\text{A is }}2(10),{\text{ C is }}3(110){\text{ and T is }}3(111). \cr}$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_008"><mml:mtable columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mml:mtr><mml:mtd/><mml:mtd><mml:mrow><mml:mtext>Given sequence</mml:mtext></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mtext>GGGGACTTAACCGGGAGTAGC</mml:mtext></mml:mrow><mml:mo>&#x02026;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mrow><mml:msub><mml:mrow><mml:mtext>F</mml:mtext></mml:mrow><mml:mrow><mml:mtext>G</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>b</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>800</mml:mn><mml:mo>,</mml:mo><mml:mrow><mml:mtext>&#x02009;</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>F</mml:mtext></mml:mrow><mml:mrow><mml:mtext>A</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>b</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>120</mml:mn><mml:mo>,</mml:mo><mml:mrow><mml:mtext>&#x02009;</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>F</mml:mtext></mml:mrow><mml:mrow><mml:mtext>C</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>b</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>60</mml:mn><mml:mo>,</mml:mo><mml:mrow><mml:mtext>&#x02009;</mml:mtext></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>F</mml:mtext></mml:mrow><mml:mrow><mml:mtext>T</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>b</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>20</mml:mn><mml:mrow><mml:mtext>&#x02009;L(b) for G is&#x02009;</mml:mtext></mml:mrow><mml:mn>1</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd/><mml:mtd><mml:mspace width="1em"/><mml:mrow><mml:mtext>A is&#x02009;</mml:mtext></mml:mrow><mml:mn>2</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mn>10</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mtext>&#x02009;C is&#x02009;</mml:mtext></mml:mrow><mml:mn>3</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mn>110</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mtext>&#x02009;and T is&#x02009;</mml:mtext></mml:mrow><mml:mn>3</mml:mn><mml:mo stretchy="false">(</mml:mo><mml:mn>111</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>.</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math><inline-graphic xlink:href="jib-15-20170057-i002.jpg"/></alternatives></inline-formula>
</p><p>The generated tree for this example is displayed in Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_005">5</xref>.</p><p>From (<xref ref-type="disp-formula" rid="j_jib-2017-0057-e002">2</xref>),</p><p>
<disp-formula id="j_jib-2017-0057-e007"><alternatives><tex-math id="M9">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$$\eqalign{ {\text{Number of bits encoded}} &#x00026; =   1 \times 800 + 2 \times 120 + 3 \times 60 + 3 \times 20 + 6 \cr &#x00026; =  1286{\text{ bits}} \cr}$$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_009"><mml:mtable columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mml:mtr><mml:mtd><mml:mrow><mml:mtext>Number of bits encoded</mml:mtext></mml:mrow><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mn>1</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>800</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>120</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>60</mml:mn><mml:mo>+</mml:mo><mml:mn>3</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:mn>20</mml:mn><mml:mo>+</mml:mo><mml:mn>6</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mn>1286</mml:mn><mml:mrow><mml:mtext>&#x02003;bits</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="jib-15-20170057-e007.jpg" position="float" orientation="portrait"/></alternatives></disp-formula>
</p><p>From (<xref ref-type="disp-formula" rid="j_jib-2017-0057-e001">1</xref>),</p><p>
<disp-formula id="j_jib-2017-0057-e008"><alternatives><tex-math id="M10">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$$\eqalign{ {\text{Compression ratio}} &#x00026; =  1286/1000{\text{ bits}}/{\text{base}} \cr &#x00026; =  {\text{1}}{\text{.286 bits/base}} \cr}$$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_010"><mml:mtable columnalign="right left" rowspacing=".5em" columnspacing="thickmathspace" displaystyle="true"><mml:mtr><mml:mtd><mml:mrow><mml:mtext>Compression ratio</mml:mtext></mml:mrow><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mn>1286</mml:mn><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mn>1000</mml:mn><mml:mrow><mml:mtext>&#x02003;bits</mml:mtext></mml:mrow><mml:mrow><mml:mo>/</mml:mo></mml:mrow><mml:mrow><mml:mtext>base</mml:mtext></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>=</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:mtext>1</mml:mtext></mml:mrow><mml:mrow><mml:mtext>.286 bits/base</mml:mtext></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="jib-15-20170057-e008.jpg" position="float" orientation="portrait"/></alternatives></disp-formula>
</p></statement><fig id="j_jib-2017-0057_fig_005" fig-type="figure" orientation="portrait" position="float"><label>Figure 5:</label><caption><p>Generated tree for Example 3.</p></caption><graphic xlink:href="jib-15-20170057-g005"/></fig></sec></sec><sec id="j_jib-2017-0057_s_004"><label>4</label><title>Result</title><p>The proposed DNA compression algorithm is a modified version of the original &#x02018;HuffBit Compress Algorithm&#x02019; and is developed using R. The algorithm is designed to achieve the best case compression ratio always, compared to the &#x02018;HuffBit Compress Algorithm&#x02019;. Several subsections are used here to describe the result of the proposed algorithm through 4.1 to 4.3.</p><sec id="j_jib-2017-0057_s_004_s_001"><label>4.1</label><title>Downloaded DNA Sequence</title><p>DNA sequence is a sequence with only four bases (a, c, g, t) of large numbers. For this analysis &#x02018;DENGUE&#x02019; DNA sequence is downloaded and saved in FASTA-format using R. The downloaded DNA sequence containing 10735 bases is then read in R for pre-processing and further analysis. The top 630 bases of the sequence are displayed in Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_006">6</xref>.</p><fig id="j_jib-2017-0057_fig_006" fig-type="figure" orientation="portrait" position="float"><label>Figure 6:</label><caption><p>Top 630 bases of DENGUE DNA sequence using R.</p></caption><graphic xlink:href="jib-15-20170057-g006"/></fig></sec><sec id="j_jib-2017-0057_s_004_s_002"><label>4.2</label><title>Pre-processing and Compression Method</title><p>Before starting the compression method, some operations must be performed on the DNA sequence such as finding out the length of the sequence; count the frequency of bases etc. Then the compression method begins with findings of the max1, max2, max3 and max4 base and replacing them with the binary value generated from the extended binary tree. Assigning A&#x02009;=&#x02009;00, C&#x02009;=&#x02009;01, G&#x02009;=&#x02009;10 and T&#x02009;=&#x02009;11 and at the last step appending 6 extra bits after the encrypted sequence.</p><p>Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_007">7</xref> displays the bottom of the compressed sequence. From Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_007">7</xref>, it is clearly viewed that each of the DNA sequence base is replaced by their corresponding code. As each base is of 8 bits and each binary unit is of 1 bit, it is obvious that the file size will be reduced to a great extent after decompression. In Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_007">7</xref>, the last 6 bits are each of a 2 bits binary number. Comparing these 6 bits with the assigned binary number a decision can be made in these ways</p><fig id="j_jib-2017-0057_fig_007" fig-type="figure" orientation="portrait" position="float"><label>Figure 7:</label><caption><p>Bottom of the compressed sequence.</p></caption><graphic xlink:href="jib-15-20170057-g007"/></fig><list list-type="order"><list-item id="j_jib-2017-0057_li_027"><p>The 1<sup>st</sup> 2 bits of the last 6 bits is 00. A is assigned to 00. So, &#x02018;a&#x02019; is the max1 base.</p></list-item><list-item id="j_jib-2017-0057_li_028"><p>The 2<sup>nd</sup> 2 bits of the last 6 bits is 10. G is assigned to 10. So, &#x02018;g&#x02019; is the max2 base.</p></list-item><list-item id="j_jib-2017-0057_li_029"><p>The 3<sup>rd</sup> 2 bits of the last 6 bits is 11. T is assigned to 11. So, &#x02018;t&#x02019; is the max3 base.</p></list-item><list-item id="j_jib-2017-0057_li_030"><p>Now the remaining base which is &#x02018;c&#x02019; is max4.</p></list-item></list></sec><sec id="j_jib-2017-0057_s_004_s_003"><label>4.3</label><title>Decompression Method</title><p>During decompression the binary codes will be replaced by their respective DNA bases. For this reason, at first max1, max2, max3 and max4 base need to be identified. To identify them, read the decompressed sequence in R and compare the last 6 bits of the sequence with the assigned binary bits. Based on this comparison, find the max1, max2, max3 and max4 base of the sequence. Then remove the last 6 binary bits and replace the binary codes with their corresponding bases such as, 0 by max1, 10 by max2, 110 by max3 and 111 by max4. Thus the original DNA sequence will be found. Save and store the sequence. The decompressed sequence will look like the downloaded DNA sequence as in Figure <xref ref-type="fig" rid="j_jib-2017-0057_fig_006">6</xref>.</p></sec></sec><sec id="j_jib-2017-0057_s_005"><label>5</label><title>Discussion</title><p>In this section, Comparison of the proposed algorithm with previous algorithms (tree based) and complexity analysis of the proposed algorithm are shown through subsections 5.1 and 5.2.</p><table-wrap id="j_jib-2017-0057_tab_001" orientation="landscape" position="float"><label>Table 1:</label><caption><p>The comparison among Modified HuffBit Compress, HuffBit Compress and 2-Bits encoding method.</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col width="16%" span="1"/><col width="5.5%" span="1"/><col width="10.5%" span="1"/><col width="8.5%" span="1"/><col width="12.5%" span="1"/><col width="13.5%" span="1"/><col width="13.5%" span="1"/><col width="13.5%" span="1"/><col width="14.5%" span="1"/><col width="14%" span="1"/><col width="14%" span="1"/><col width="14%" span="1"/></colgroup><thead><tr><th align="left" valign="top" colspan="1" rowspan="1">DNA Sequence length</th><th align="left" valign="top" colspan="1" rowspan="1">Base</th><th align="right" valign="top" colspan="1" rowspan="1">Base frequency</th><th align="right" valign="top" colspan="1" rowspan="1">Binary bits</th><th align="right" valign="top" colspan="1" rowspan="1">Compression ratio for Modified HuffBit Compress (bpb)</th><th align="right" valign="top" colspan="1" rowspan="1">(%) Compression ratio for Modified HuffBit Compress</th><th align="right" valign="top" colspan="1" rowspan="1">Compression ratio for HuffBit Compress (bpb)</th><th align="right" valign="top" colspan="1" rowspan="1">(%) Compression Ratio for HuffBit Compress</th><th align="right" valign="top" colspan="1" rowspan="1">(%) Improvement of Modified HuffBit Compress over HuffBit Compress</th><th align="right" valign="top" colspan="1" rowspan="1">Compression Ratio for 2-Bits Encoding Method (bpb)</th><th align="right" valign="top" colspan="1" rowspan="1">(%) Compression Ratio for 2-Bits Encoding Method</th><th align="right" valign="top" colspan="1" rowspan="1">(%) Improvement of Modified HuffBit Compress over 2-Bits Encoding Method</th></tr></thead><tbody><tr><td align="left" valign="top" colspan="1" rowspan="1">1. Sequence: 100</td><td align="left" valign="top" colspan="1" rowspan="1">A</td><td align="right" valign="top" colspan="1" rowspan="1">45</td><td align="right" valign="top" colspan="1" rowspan="1">0</td><td align="right" valign="top" colspan="1" rowspan="1">1.71</td><td align="right" valign="top" colspan="1" rowspan="1">21.375</td><td align="right" valign="top" colspan="1" rowspan="1">2.05</td><td align="right" valign="top" colspan="1" rowspan="1">25.625</td><td align="right" valign="top" colspan="1" rowspan="1">16.59</td><td align="right" valign="top" colspan="1" rowspan="1">2</td><td align="right" valign="top" colspan="1" rowspan="1">25</td><td align="right" valign="top" colspan="1" rowspan="1">14.5</td></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">T</td><td align="right" valign="top" colspan="1" rowspan="1">45</td><td align="right" valign="top" colspan="1" rowspan="1">10</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">C</td><td align="right" valign="top" colspan="1" rowspan="1">5</td><td align="right" valign="top" colspan="1" rowspan="1">110</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">G</td><td align="right" valign="top" colspan="1" rowspan="1">5</td><td align="right" valign="top" colspan="1" rowspan="1">111</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1">2. Sequence: 600</td><td align="left" valign="top" colspan="1" rowspan="1">A</td><td align="right" valign="top" colspan="1" rowspan="1">275</td><td align="right" valign="top" colspan="1" rowspan="1">0</td><td align="right" valign="top" colspan="1" rowspan="1">1.635</td><td align="right" valign="top" colspan="1" rowspan="1">20.4375</td><td align="right" valign="top" colspan="1" rowspan="1">2.04</td><td align="right" valign="top" colspan="1" rowspan="1">25.520</td><td align="right" valign="top" colspan="1" rowspan="1">19.92</td><td align="right" valign="top" colspan="1" rowspan="1">2</td><td align="right" valign="top" colspan="1" rowspan="1">25</td><td align="right" valign="top" colspan="1" rowspan="1">18.25</td></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">T</td><td align="right" valign="top" colspan="1" rowspan="1">275</td><td align="right" valign="top" colspan="1" rowspan="1">10</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">C</td><td align="right" valign="top" colspan="1" rowspan="1">25</td><td align="right" valign="top" colspan="1" rowspan="1">110</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">G</td><td align="right" valign="top" colspan="1" rowspan="1">25</td><td align="right" valign="top" colspan="1" rowspan="1">111</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1">3. Sequence: 500</td><td align="left" valign="top" colspan="1" rowspan="1">C</td><td align="right" valign="top" colspan="1" rowspan="1">300</td><td align="right" valign="top" colspan="1" rowspan="1">0</td><td align="right" valign="top" colspan="1" rowspan="1">1.612</td><td align="right" valign="top" colspan="1" rowspan="1">20.15</td><td align="right" valign="top" colspan="1" rowspan="1">2.1</td><td align="right" valign="top" colspan="1" rowspan="1">26.25</td><td align="right" valign="top" colspan="1" rowspan="1">23.24</td><td align="right" valign="top" colspan="1" rowspan="1">2</td><td align="right" valign="top" colspan="1" rowspan="1">25</td><td align="right" valign="top" colspan="1" rowspan="1">19.4</td></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">T</td><td align="right" valign="top" colspan="1" rowspan="1">100</td><td align="right" valign="top" colspan="1" rowspan="1">10</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">A</td><td align="right" valign="top" colspan="1" rowspan="1">75</td><td align="right" valign="top" colspan="1" rowspan="1">110</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">G</td><td align="right" valign="top" colspan="1" rowspan="1">25</td><td align="right" valign="top" colspan="1" rowspan="1">111</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1">4. Sequence: 64</td><td align="left" valign="top" colspan="1" rowspan="1">T</td><td align="right" valign="top" colspan="1" rowspan="1">40</td><td align="right" valign="top" colspan="1" rowspan="1">0</td><td align="right" valign="top" colspan="1" rowspan="1">1.625</td><td align="right" valign="top" colspan="1" rowspan="1">20.3125</td><td align="right" valign="top" colspan="1" rowspan="1">2.75</td><td align="right" valign="top" colspan="1" rowspan="1">32.031</td><td align="right" valign="top" colspan="1" rowspan="1">36.58</td><td align="right" valign="top" colspan="1" rowspan="1">2</td><td align="right" valign="top" colspan="1" rowspan="1">25</td><td align="right" valign="top" colspan="1" rowspan="1">18.75</td></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">C</td><td align="right" valign="top" colspan="1" rowspan="1">14</td><td align="right" valign="top" colspan="1" rowspan="1">10</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">A</td><td align="right" valign="top" colspan="1" rowspan="1">7</td><td align="right" valign="top" colspan="1" rowspan="1">110</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">G</td><td align="right" valign="top" colspan="1" rowspan="1">3</td><td align="right" valign="top" colspan="1" rowspan="1">111</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1">5. Sequence: 200</td><td align="left" valign="top" colspan="1" rowspan="1">A</td><td align="right" valign="top" colspan="1" rowspan="1">80</td><td align="right" valign="top" colspan="1" rowspan="1">0</td><td align="right" valign="top" colspan="1" rowspan="1">1.98</td><td align="right" valign="top" colspan="1" rowspan="1">24.75</td><td align="right" valign="top" colspan="1" rowspan="1">1.95</td><td align="right" valign="top" colspan="1" rowspan="1">24.375</td><td align="right" valign="top" colspan="1" rowspan="1">&#x02212;1.54</td><td align="right" valign="top" colspan="1" rowspan="1">2</td><td align="right" valign="top" colspan="1" rowspan="1">25</td><td align="right" valign="top" colspan="1" rowspan="1">1</td></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">C</td><td align="right" valign="top" colspan="1" rowspan="1">50</td><td align="right" valign="top" colspan="1" rowspan="1">10</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">G</td><td align="right" valign="top" colspan="1" rowspan="1">40</td><td align="right" valign="top" colspan="1" rowspan="1">110</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">T</td><td align="right" valign="top" colspan="1" rowspan="1">30</td><td align="right" valign="top" colspan="1" rowspan="1">111</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1">6. Downloaded Dengue Sequence: 10735</td><td align="left" valign="top" colspan="1" rowspan="1">A</td><td align="right" valign="top" colspan="1" rowspan="1">3426</td><td align="right" valign="top" colspan="1" rowspan="1">0</td><td align="right" valign="top" colspan="1" rowspan="1">2.10</td><td align="right" valign="top" colspan="1" rowspan="1">26.30</td><td align="right" valign="top" colspan="1" rowspan="1">2.15</td><td align="right" valign="top" colspan="1" rowspan="1">26.91</td><td align="right" valign="top" colspan="1" rowspan="1">2.27</td><td align="right" valign="top" colspan="1" rowspan="1">2</td><td align="right" valign="top" colspan="1" rowspan="1">25</td><td align="right" valign="top" colspan="1" rowspan="1">&#x02212;5.2</td></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">G</td><td align="right" valign="top" colspan="1" rowspan="1">2770</td><td align="right" valign="top" colspan="1" rowspan="1">10</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">T</td><td align="right" valign="top" colspan="1" rowspan="1">2299</td><td align="right" valign="top" colspan="1" rowspan="1">110</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">C</td><td align="right" valign="top" colspan="1" rowspan="1">2240</td><td align="right" valign="top" colspan="1" rowspan="1">111</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1"/></tr></tbody></table></table-wrap><sec id="j_jib-2017-0057_s_005_s_001"><label>5.1</label><title>Comparison with Prior Algorithms</title><p>The most natural benchmark of the proposed algorithm is a comparison with the other compression algorithms designed to compress DNA sequences.</p><p>This comparison can be done by using the compression ratio. The ratio of the original, uncompressed data file to the compressed file is referred to as the compression ratio. The comparison among Modified HuffBit Compress, HuffBit Compress and 2-Bits Encoding Method are given in Table <xref rid="j_jib-2017-0057_tab_001" ref-type="table">1</xref>.</p><p>In the table,</p><p>
<disp-formula id="j_jib-2017-0057-e009"><label>(3)</label><alternatives><tex-math id="M11">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$${\text{Percentage Compression ratio}} = ({\text{Number of byte encoded /Number of bases}}) \times 100{\text{ }}\%$$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_011"><mml:mrow><mml:mtext>Percentage Compression ratio</mml:mtext></mml:mrow><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mtext>Number of byte encoded /Number of bases</mml:mtext></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x000d7;</mml:mo><mml:mn>100</mml:mn><mml:mrow><mml:mtext>&#x02003;</mml:mtext></mml:mrow><mml:mi mathvariant="normal">%</mml:mi></mml:math><graphic xlink:href="jib-15-20170057-e009.jpg" position="float" orientation="portrait"/></alternatives></disp-formula>
</p><p>
<disp-formula id="j_jib-2017-0057-e010"><label>(4)</label><alternatives><tex-math id="M12">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$$\begin{array}{ll} {\text{Improvement of Modified HuffBit Compress over HuffBit Compress}} = \\ \quad  \quad ({\text{Percentage Compression ratio for HuffBit Compress}} - \\ \quad \quad {\text{Percentage Compression ratio for Modified HuffBit Compress}})/\\ \quad \quad {\text{Percentage Compression ratio for HuffBit Compress}} * 100{\text{ }}\% \end{array}$$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_012"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mrow><mml:mtext>Improvement of Modified HuffBit Compress over HuffBit Compress</mml:mtext></mml:mrow><mml:mo>=</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mtext>Percentage Compression ratio for HuffBit Compress</mml:mtext></mml:mrow><mml:mo>&#x02212;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mrow><mml:mtext>Percentage Compression ratio for Modified HuffBit Compress</mml:mtext></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>/</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mrow><mml:mtext>Percentage Compression ratio for HuffBit Compress</mml:mtext></mml:mrow><mml:mo>&#x02217;</mml:mo><mml:mn>100</mml:mn><mml:mrow><mml:mtext>&#x02003;</mml:mtext></mml:mrow><mml:mi mathvariant="normal">%</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="jib-15-20170057-e010.jpg" position="float" orientation="portrait"/></alternatives></disp-formula>
</p><p>
<disp-formula id="j_jib-2017-0057-e011"><label>(5)</label><alternatives><tex-math id="M13">\documentclass[10pt]{article}
    \usepackage{wasysym}
    \usepackage[substack]{amsmath}
    \usepackage{amsfonts}
    \usepackage{amssymb}
    \usepackage{amsbsy}
    \usepackage[mathscr]{eucal}
    \usepackage{mathrsfs}
    \usepackage{pmc}
    \usepackage[Euler]{upgreek}
    \pagestyle{empty}
    \oddsidemargin -1.0in
    \begin{document}
$$\begin{array}{ll} {\text{Improvement of Modified HuffBit Compress over }}2{\text{ Bits Encoding Method}} = \\ \quad \quad ({\text{Percentage Compression ratio for }}2{\text{ Bits Encoding Method }} - \\ \quad \quad {\text{ Percentage Compression ratio for Modified HuffBit Compress}})/\\ \quad \quad{\text{Percentage Compression ratio for }}2{\text{ Bits Encoding Method}} * 100{\text{ }}\% \end{array}$$
\end{document}
   </tex-math><mml:math id="j_jib-2017-0057_math_013"><mml:mtable columnalign="left left" rowspacing="4pt" columnspacing="1em"><mml:mtr><mml:mtd><mml:mrow><mml:mtext>Improvement of Modified HuffBit Compress over&#x02003;</mml:mtext></mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mtext>&#x02003;Bits Encoding Method</mml:mtext></mml:mrow><mml:mo>=</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mtext>Percentage Compression ratio for&#x02003;</mml:mtext></mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mtext>&#x02003;Bits Encoding Method&#x02003;</mml:mtext></mml:mrow><mml:mo>&#x02212;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mrow><mml:mtext>&#x02003;Percentage Compression ratio for Modified HuffBit Compress</mml:mtext></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo>/</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mspace width="1em"/><mml:mspace width="1em"/><mml:mrow><mml:mtext>Percentage Compression ratio for&#x02003;</mml:mtext></mml:mrow><mml:mn>2</mml:mn><mml:mrow><mml:mtext>&#x02003;Bits Encoding Method</mml:mtext></mml:mrow><mml:mo>&#x02217;</mml:mo><mml:mn>100</mml:mn><mml:mrow><mml:mtext>&#x02003;</mml:mtext></mml:mrow><mml:mi mathvariant="normal">%</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math><graphic xlink:href="jib-15-20170057-e011.jpg" position="float" orientation="portrait"/></alternatives></disp-formula>
</p><p>From the table, it is observed that The &#x0201c;Modified Huffbit Compress Algorithm&#x0201d; performs better than &#x0201c;Huffbit Compress&#x0201d; algorithm and &#x0201c;2 Bits Encoding Method&#x0201d; for sequence 1, 2, 3, 4 but for sequence 5, &#x0201c;HuffBit Compress&#x0201d; and for sequence 6, &#x0201c;2 Bits Encoding Method&#x0201d; gives better result. Therefore, the average improvement of using the proposed algorithm is 16.18&#x02009;% and 11.12&#x02009;% compared to &#x0201c;HuffBit Compress&#x0201d; and &#x0201c;2 Bits Encoding Method&#x0201d; respectively. The article by Ghoshdastider and Saha [<xref rid="j_jib-2017-0057_ref_023" ref-type="bibr">23</xref>] mentioned that for a sequence of length 64, GenCompress, Biocompress and other software takes about 14 bytes for compressed sequence while in &#x0201c;Modified Huffbit Compress Algorithm&#x0201d; sequence 4 with a length of 64 needs 13 bytes for compressed sequence. Thus the proposed algorithm performs well for most of the cases but it has some limitations also.</p><list list-type="order"><list-item id="j_jib-2017-0057_li_031"><p>If the sequence length is small then the extra 6 bits in the compressed file cannot be neglected and compression ratio increases. But, as in most cases, DNA sequences are too large; so that issue might not be a problem.</p></list-item><list-item id="j_jib-2017-0057_li_032"><p>Compression ratio depends on max1, max2, max3 and max4. So, if there exists a large number of max3 and max4 then the compression ratio also increases.</p></list-item></list><p>Nevertheless, the proposed algorithm performs better in most cases.</p></sec><sec id="j_jib-2017-0057_s_005_s_002"><label>5.2</label><title>Complexity Analysis of Proposed Algorithm</title><p>Complexity of an algorithm is a measure of the amount of time and/or space required by an algorithm for an input of a given size (n) [<xref rid="j_jib-2017-0057_ref_024" ref-type="bibr">24</xref>]. It indicates how fast or slow an algorithm actually performs. The time complexity is usually expressed using big O notation. The time complexity of an algorithm is a measure of the amount of time taken by an algorithm to run. The time complexity of proposed algorithm and &#x02018;HuffBit Compress Algorithm&#x02019; can be shown as in Table <xref rid="j_jib-2017-0057_tab_002" ref-type="table">2</xref>.</p><table-wrap id="j_jib-2017-0057_tab_002" orientation="portrait" position="float"><label>Table 2:</label><caption><p>Time complexity of proposed algorithm and &#x02018;HuffBit Compress Algorithm&#x02019;.</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col width="40%" span="1"/><col width="20%" span="1"/><col width="40%" span="1"/></colgroup><thead><tr><th align="left" valign="top" colspan="1" rowspan="1">Proposed algorithm compression method</th><th align="left" valign="top" colspan="1" rowspan="1">Time complexity</th><th align="left" valign="top" colspan="1" rowspan="1">HuffBit Compress Algorithm</th></tr></thead><tbody><tr><td align="left" valign="top" colspan="1" rowspan="1">1. Counting the frequency of each base</td><td align="left" valign="top" colspan="1" rowspan="1">O(n)</td><td align="left" valign="top" colspan="1" rowspan="1">Counting the frequency of each base</td></tr><tr><td align="left" valign="top" colspan="1" rowspan="1">2. Finding max1, max2, max3, max4 base</td><td align="left" valign="top" colspan="1" rowspan="1">O(4)</td><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1">3. Encryption Operation</td><td align="left" valign="top" colspan="1" rowspan="1">4*O(n)</td><td align="left" valign="top" colspan="1" rowspan="1">Encryption operation</td></tr><tr><td align="left" valign="top" colspan="1" rowspan="1">4. Assigning binary bits</td><td align="left" valign="top" colspan="1" rowspan="1">O(1)</td><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1">5. Appending last 6 bits</td><td align="left" valign="top" colspan="1" rowspan="1">O(4)</td><td align="left" valign="top" colspan="1" rowspan="1"/></tr><tr><td align="left" valign="top" colspan="1" rowspan="1">Total&#x02009;=&#x02009;O(n)&#x02009;+&#x02009;O(4)&#x02009;+&#x02009;4*O(n)&#x02009;+&#x02009;O(1)&#x02009;+&#x02009;O(4)<break/>&#x02003;&#x02003;&#x02009;=&#x02009;5*O(n)&#x02009;+&#x02009;O(9)<break/>&#x02003;&#x02003;&#x02009;~&#x02009;5*O(n)</td><td align="left" valign="top" colspan="1" rowspan="1"/><td align="left" valign="top" colspan="1" rowspan="1">Total&#x02009;=&#x02009;O(n)+4*O(n)<break/>&#x02003;&#x02003;&#x02009;=&#x02009;5*O(n)</td></tr></tbody></table></table-wrap><p>From Table <xref rid="j_jib-2017-0057_tab_002" ref-type="table">2</xref>, it is ensured that the time complexity of the proposed &#x02018;Modified HuffBit Compress Algorithm&#x02019; is approximately same as &#x02018;HuffBit Compress Algorithm&#x02019;. Also proposed algorithm always gives best case compression ratio than &#x02018;HuffBit Compress Algorithm&#x02019;. So, using &#x02018;Modified HuffBit Compress Algorithm&#x02019; will be more fruitful for DNA sequence compression.</p></sec></sec><sec id="j_jib-2017-0057_s_006"><label>6</label><title>Conclusion</title><p>DNA compression is an important topic in bioinformatics which helps in storage, manipulation and transformation of large DNA sequences. If the sequence is compressed using Modified HuffBit Compress algorithm, it will be easier to compress large bytes of DNA sequences with better compression ratio. An advantage of the proposed algorithm is, it works well for large sequences. So, it can be helpful to save storage problem greatly. Moreover, it uses less time, memory and easy to implement using R. This research also creates a new dimension of using R in DNA compression which is the main potentiality of the research work. The future work of the research is to overcome the limitations of the proposed algorithm and to come with a better outcome.</p></sec></body><back><ack id="j_jib-2017-0057_ack_001"><title>Acknowledgments</title><p>The authors are grateful to the participants who contributed to this research. No financial support is provided from any organization during the research project.</p></ack><sec sec-type="COI-statement"><title>Conflict of interest statement</title><p>Authors state no conflict of interest. All authors have read the journal&#x02019;s publication ethics and publication malpractice statement available at the journal&#x02019;s website and hereby confirm that they comply with all its parts applicable to the present scientific work.</p></sec><ref-list id="j_jib-2017-0057_reflist_001"><title>References</title><ref id="j_jib-2017-0057_ref_001"><label>[1]</label><element-citation publication-type="journal"><source>PROGRAMIZ</source><date-in-citation>Accessed Sepetember 19, 2017</date-in-citation><comment><ext-link ext-link-type="uri" xlink:href="https://www.programiz.com/r-programming">https://www.programiz.com/r-programming</ext-link></comment></element-citation></ref><ref id="j_jib-2017-0057_ref_002"><label>[2]</label><element-citation publication-type="journal"><name><surname>Vance</surname><given-names>A</given-names></name><article-title>Data analysts captivated by R&#x02019;s Power</article-title><source>NY Times</source><year>2009</year><comment>URL <ext-link ext-link-type="uri" xlink:href="http://www.nytimes.com/2009/01/07/technology/business-computing/07program.html?_r=1">http://www.nytimes.com/2009/01/07/technology/business-computing/07program.html?_r=1</ext-link></comment></element-citation></ref><ref id="j_jib-2017-0057_ref_003"><label>[3]</label><element-citation publication-type="journal"><collab>Timothy Prickett Morgan</collab><article-title>Open source R in commercial revolution</article-title><source>The Register</source><year>2010</year><comment>URL <ext-link ext-link-type="uri" xlink:href="http://www.theregister.co.uk/2010/05/06/revolution_commercial_r/">http://www.theregister.co.uk/2010/05/06/revolution_commercial_r/</ext-link></comment></element-citation></ref><ref id="j_jib-2017-0057_ref_004"><label>[4]</label><element-citation publication-type="journal"><source>Genetics Home Reference</source><date-in-citation>Accessed March 15, 2017</date-in-citation><ext-link ext-link-type="uri" xlink:href="https://ghr.nlm.nih.gov/primer/hgp/genome">https://ghr.nlm.nih.gov/primer/hgp/genome</ext-link></element-citation></ref><ref id="j_jib-2017-0057_ref_005"><label>[5]</label><element-citation publication-type="journal"><name><surname>Bharti</surname><given-names>RK</given-names></name><name><surname>Singh</surname><given-names>RK</given-names></name><article-title>A biological sequence compression based on look up table (LUT) using complementary palindrome of fixed size</article-title><source>Int J Comput Appl</source><year>2011</year><volume>35</volume><fpage>0975</fpage><lpage>8887</lpage></element-citation></ref><ref id="j_jib-2017-0057_ref_006"><label>[6]</label><element-citation publication-type="journal"><name><surname>Grumbach</surname><given-names>S</given-names></name><name><surname>Tahi</surname><given-names>F</given-names></name><article-title>A new challenge for compression algorithms: genetic sequences</article-title><source>Inf Process Manage</source><year>1994</year><volume>30</volume><fpage>875</fpage><lpage>86</lpage></element-citation></ref><ref id="j_jib-2017-0057_ref_007"><label>[7]</label><element-citation publication-type="journal"><source>Genomatix</source><date-in-citation>Accessed March 15, 2017</date-in-citation><comment><ext-link ext-link-type="uri" xlink:href="https://www.genomatix.de/online_help/help/sequence_formats.html">https://www.genomatix.de/online_help/help/sequence_formats.html</ext-link></comment></element-citation></ref><ref id="j_jib-2017-0057_ref_008"><label>[8]</label><element-citation publication-type="journal"><source>GenBank and WGS Statistics (NCBI)</source><date-in-citation>Accessed March 15, 2017</date-in-citation><comment><ext-link ext-link-type="uri" xlink:href="https://www.ncbi.nlm.nih.gov/genbank/statistics/">https://www.ncbi.nlm.nih.gov/genbank/statistics/</ext-link></comment></element-citation></ref><ref id="j_jib-2017-0057_ref_009"><label>[9]</label><element-citation publication-type="journal"><name><surname>Koonin</surname><given-names>EV</given-names></name><article-title>The emerging paradigm and open problems in comparative genomics</article-title><source>Bioinformatics</source><year>1999</year><volume>15</volume><fpage>265</fpage><lpage>6</lpage><pub-id pub-id-type="pmid">10438229</pub-id></element-citation></ref><ref id="j_jib-2017-0057_ref_010"><label>[10]</label><element-citation publication-type="journal"><name><surname>Wooley</surname><given-names>JC</given-names></name><article-title>Trends in computational biology: a summary based on a RECOMB plenary lecture, 1999</article-title><source>J Comput Biol</source><year>2004</year><volume>6</volume><fpage>459</fpage><lpage>474</lpage></element-citation></ref><ref id="j_jib-2017-0057_ref_011"><label>[11]</label><element-citation publication-type="journal"><name><surname>Bennett</surname><given-names>CH</given-names></name><name><surname>Gacs</surname><given-names>P</given-names></name><name><surname>Li</surname><given-names>M</given-names></name><name><surname>Vitanyi</surname><given-names>PMB</given-names></name><name><surname>Zurek</surname><given-names>WH</given-names></name><article-title>Information Distance</article-title><source>IEEE Trans Inf Theory</source><year>1998</year><volume>44</volume><fpage>4</fpage></element-citation></ref><ref id="j_jib-2017-0057_ref_012"><label>[12]</label><element-citation publication-type="book"><name><surname>Rivals</surname><given-names>E</given-names></name><name><surname>Delahaye</surname><given-names>J-P</given-names></name><name><surname>Dauchet</surname><given-names>M</given-names></name><name><surname>Delgrange</surname><given-names>O</given-names></name><source>A guaranteed compression scheme for repetitive DNA sequences</source><comment>LIFL I University, technical report 1995; IT-285</comment></element-citation></ref><ref id="j_jib-2017-0057_ref_013"><label>[13]</label><element-citation publication-type="journal"><name><surname>Rajarajeswari</surname><given-names>P</given-names></name><name><surname>Apparao</surname><given-names>A</given-names></name><article-title>DNABIT compress &#x02013; genome compression algorithm</article-title><source>Bioinformation</source><year>2011</year><volume>5</volume><fpage>350</fpage><lpage>60</lpage><pub-id pub-id-type="pmid">21383923</pub-id></element-citation></ref><ref id="j_jib-2017-0057_ref_014"><label>[14]</label><element-citation publication-type="confproc"><name><surname>Grumbach</surname><given-names>S</given-names></name><name><surname>Tahi</surname><given-names>F</given-names></name><source>Compression of DNA sequences</source><conf-name>IEEE Symposium on the Data Compression Conference, DCC-93</conf-name><conf-loc>Snowbird, UT</conf-loc><year>1993</year><fpage>340</fpage><lpage>50</lpage></element-citation></ref><ref id="j_jib-2017-0057_ref_015"><label>[15]</label><element-citation publication-type="journal"><name><surname>Ziv</surname><given-names>J</given-names></name><name><surname>Lempel</surname><given-names>A</given-names></name><article-title>A Universal Algorithm for Sequential Data Compression</article-title><source>IEEE Trans Inf Theory</source><year>1977</year><volume>IT-23</volume><fpage>337</fpage></element-citation></ref><ref id="j_jib-2017-0057_ref_016"><label>[16]</label><element-citation publication-type="journal"><name><surname>ZIV</surname><given-names>J</given-names></name><article-title>Coding Theorems for Individual Sequences</article-title><source>IEEE Trans Inf Theory</source><year>1978</year><volume>IT-24</volume><comment>[PMID: 20157474]</comment></element-citation></ref><ref id="j_jib-2017-0057_ref_017"><label>[17]</label><element-citation publication-type="journal"><name><surname>Bakr</surname><given-names>NS</given-names></name><name><surname>Sharawi</surname><given-names>AA</given-names></name><article-title>DNA lossless compression algorithms: review</article-title><source>Am J Bioinform Res</source><year>2013</year><volume>3</volume><fpage>72</fpage><lpage>81</lpage></element-citation></ref><ref id="j_jib-2017-0057_ref_018"><label>[18]</label><element-citation publication-type="journal"><name><surname>Bharti</surname><given-names>RK</given-names></name><name><surname>Harbola</surname><given-names>D</given-names></name><article-title>State of the art: DNA compression algorithms</article-title><source>IJARCSSE</source><year>2013</year><volume>3</volume><fpage>397</fpage></element-citation></ref><ref id="j_jib-2017-0057_ref_019"><label>[19]</label><element-citation publication-type="confproc"><name><surname>Rivals</surname><given-names>E</given-names></name><name><surname>Dauchet</surname><given-names>M</given-names></name><source>Fast discerning repeats in DNA sequences with a compression algorithm</source><conf-name>The 8th Workshop on Genome and Informatics, (GIW97)</conf-name><year>1997</year><fpage>215</fpage><lpage>26</lpage><volume>8</volume></element-citation></ref><ref id="j_jib-2017-0057_ref_020"><label>[20]</label><element-citation publication-type="journal"><name><surname>Chen</surname><given-names>X</given-names></name><name><surname>Li</surname><given-names>M</given-names></name><name><surname>Ma</surname><given-names>B</given-names></name><name><surname>Tromp</surname><given-names>J</given-names></name><article-title>DNACompress: fast and effective DNA sequence compression</article-title><source>Bioinformatics</source><year>2002</year><volume>18</volume><fpage>1696</fpage><lpage>8</lpage><pub-id pub-id-type="pmid">12490460</pub-id></element-citation></ref><ref id="j_jib-2017-0057_ref_021"><label>[21]</label><element-citation publication-type="journal"><name><surname>Ma</surname><given-names>B</given-names></name><name><surname>Tromp</surname><given-names>J</given-names></name><name><surname>Li</surname><given-names>M</given-names></name><article-title>PatternHunter &#x02013; faster and more sensitive homology search</article-title><source>Bioinformatics</source><year>2002</year><volume>18</volume><fpage>440</fpage><lpage>5</lpage><pub-id pub-id-type="pmid">11934743</pub-id></element-citation></ref><ref id="j_jib-2017-0057_ref_022"><label>[22]</label><element-citation publication-type="journal"><name><surname>Raja Rajeswari</surname><given-names>P</given-names></name><name><surname>Apparao</surname><given-names>A</given-names></name><name><surname>Kiran Kumar</surname><given-names>R</given-names></name><article-title>HUFFBIT COMPRESS &#x02013; algorithm to compress DNA sequences using extended binary trees</article-title><source>J Theor Appl Inf Technol</source><year>2010</year><volume>13</volume><fpage>101</fpage><lpage>6</lpage></element-citation></ref><ref id="j_jib-2017-0057_ref_023"><label>[23]</label><element-citation publication-type="book"><name><surname>Ghoshdastider</surname><given-names>U</given-names></name><name><surname>Saha</surname><given-names>B</given-names></name><source>GenomeCompress: a novel algorithm for DNA compression</source><year>2007</year></element-citation></ref><ref id="j_jib-2017-0057_ref_024"><label>[24]</label><element-citation publication-type="journal"><source>Complexity</source><date-in-citation>Accessed August 17, 2017</date-in-citation><comment><ext-link ext-link-type="uri" xlink:href="http://www.dcs.gla.ac.uk/~pat/52233/complexity.html">http://www.dcs.gla.ac.uk/~pat/52233/complexity.html</ext-link></comment></element-citation></ref></ref-list></back></article>